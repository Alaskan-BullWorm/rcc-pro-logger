<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>RCC Pro Logger — Grid Coords + Annotated Exports</title>
<meta name="color-scheme" content="dark light" />
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
<style>
  :root{
    --bg:#0b1220;--panel:#101826;--muted:#9aa5b1;--text:#e6e8eb;--brand:#22d3ee;
    --ok:#34d399;--warn:#fbbf24;--err:#f87171;--stroke:rgba(148,163,184,.25);
    --radius:12px;--shadow:0 12px 32px rgba(0,0,0,.35);
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;background:var(--bg);color:var(--text);font:14px/1.45 Inter,system-ui,Segoe UI,Roboto,Arial}
  header{position:sticky;top:0;z-index:10;background:linear-gradient(to bottom,rgba(16,24,38,.9),rgba(16,24,38,.6));border-bottom:1px solid var(--stroke);backdrop-filter:blur(10px) saturate(140%)}
  .nav{max-width:1200px;margin:0 auto;padding:12px 18px;display:grid;grid-template-columns:1fr auto 1fr;align-items:center;gap:8px}
  .brand{display:inline-flex;gap:10px;font-weight:700}
  .logo{width:26px;height:26px;border-radius:8px;background:linear-gradient(135deg,var(--brand),#0891b2);box-shadow:inset 0 0 10px rgba(255,255,255,.25),0 6px 16px rgba(8,145,178,.45)}
  nav a{color:var(--muted);text-decoration:none;padding:8px 10px;border-radius:8px}
  nav a[aria-current="page"],nav a:hover{color:var(--text);background:rgba(148,163,184,.15)}
  .right{justify-self:end;display:flex;gap:8px}
  .btn{border:1px solid var(--stroke);background:linear-gradient(180deg,rgba(2,6,23,.5),rgba(2,6,23,.2));color:var(--text);padding:8px 12px;border-radius:10px;cursor:pointer}
  .btn.primary{border-color:rgba(34,211,238,.4);background:linear-gradient(180deg,rgba(34,211,238,.18),rgba(8,145,178,.14))}
  .btn.danger{border-color:rgba(248,113,113,.45)}
  .btn:disabled{opacity:.6;cursor:not-allowed}
  main{max-width:1200px;margin:20px auto 60px;padding:0 18px}
  .grid{display:grid;gap:16px;grid-template-columns:repeat(12,1fr)}
  .card{grid-column:span 12;background:linear-gradient(180deg,rgba(255,255,255,.05),rgba(255,255,255,.03));border:1px solid var(--stroke);border-radius:var(--radius);box-shadow:var(--shadow);padding:16px}
  @media(min-width:900px){.span-4{grid-column:span 4}.span-6{grid-column:span 6}.span-8{grid-column:span 8}.span-12{grid-column:span 12}}
  .row{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  .field{display:flex;flex-direction:column;gap:6px;min-width:140px}
  .field label{color:var(--muted);font-size:12px}
  .field input,.field select{border:1px solid var(--stroke);background:#0e1626;color:var(--text);border-radius:10px;padding:8px 10px}
  .muted{color:var(--muted)}
  .canvasWrap{position:relative;border:1px solid var(--stroke);border-radius:10px;overflow:hidden;touch-action:none;background:#0a1020}
  canvas{display:block;width:100%;height:auto}
  .handle{position:absolute;width:12px;height:12px;border:2px solid #fff;border-radius:2px;background:rgba(0,0,0,.35);box-shadow:0 0 0 1px rgba(0,0,0,.5)}
  .toast{position:fixed;right:16px;bottom:16px;background:#0b1220;border:1px solid var(--stroke);border-radius:12px;padding:10px 12px;display:none;min-width:240px}
  .toast.show{display:block;animation:pop .2s ease-out}
  @keyframes pop{from{transform:translateY(6px);opacity:0}to{transform:translateY(0);opacity:1}}
  table{width:100%;border-collapse:collapse}
  th,td{padding:10px;border-bottom:1px solid rgba(148,163,184,.15);text-align:left}
  th{background:rgba(148,163,184,.12);position:sticky;top:0}
  td input{width:100%;padding:6px 8px;border-radius:8px;border:1px solid var(--stroke);background:#0f172a;color:var(--text)}
  .pill{display:inline-flex;gap:6px;align-items:center}
  .dot{width:8px;height:8px;border-radius:50%;background:var(--ok);box-shadow:0 0 10px var(--ok)}
</style>
</head>
<body>
<header>
  <div class="nav">
    <div class="brand"><div class="logo" aria-hidden="true"></div><span>RCC <span style="opacity:.75">Pro</span></span></div>
    <nav class="tabbar" role="tablist" aria-label="Primary">
      <a id="tab-setup" href="#/setup" role="tab" aria-selected="true">Job Setup</a>
      <a id="tab-entry" href="#/entry" role="tab">RCC Results Entry</a>
      <a id="tab-summary" href="#/summary" role="tab">Summary</a>
    </nav>
    <div class="right">
      <button class="btn" id="btn-refresh">↻ Refresh</button>
      <button class="btn primary" id="btn-export">Export ▾</button>
    </div>
  </div>
</header>

<main>
  <div id="outlet" class="grid"></div>
</main>

<div id="toast" class="toast" role="status" aria-live="polite"></div>

<!-- jsPDF for PDF export -->
<script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>

<script>
/* =========================
   RCC Pro — Grid Coordinates
   ========================= */

const $ = (sel, root=document) => root.querySelector(sel);
const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));
const toast = (msg, kind='info') => {
  const t = $('#toast');
  t.textContent = msg;
  t.style.borderColor = {info:'var(--stroke)',ok:'rgba(16,185,129,.45)',warn:'rgba(245,158,11,.45)',err:'rgba(244,63,94,.45)'}[kind]||'var(--stroke)';
  t.classList.add('show');
  clearTimeout(t._timer);
  t._timer = setTimeout(()=>t.classList.remove('show'), 2200);
};

// ---------- State ----------
const state = {
  job: { name:'', date: new Date().toISOString().slice(0,10) },
  image: null,                 // HTMLImageElement
  imgW: 0, imgH: 0,            // intrinsic size
  roi: null,                   // {x,y,w,h} in image pixels
  grid: {
    rows: 12, cols: 12,
    orientation: 'letters-rows', // 'letters-rows' or 'numbers-rows'
    marginTop: 28, marginLeft: 28,
    headerShade: true,
    labelColor: '#ffffff',
    labelShadow: '#000000'
  },
  tests: []                    // {id,num,location,wd,moist,coord,row,col,x,y}
};

// ---------- Router ----------
const routes = {
  '/setup': renderSetup,
  '/entry': renderEntry,
  '/summary': renderSummary
};
window.addEventListener('hashchange', onRoute);
window.addEventListener('DOMContentLoaded', () => {
  onRoute();
  $('#btn-refresh').addEventListener('click', ()=> { onRoute(true); toast('Refreshed'); });
  $('#btn-export').addEventListener('click', () => showExportMenu());
});

function onRoute(force=false) {
  const path = location.hash.replace('#','') || '/setup';
  for (const [p,id] of Object.entries({'/setup':'tab-setup','/entry':'tab-entry','/summary':'tab-summary'})) {
    const el = $('#'+id);
    if (el) el.setAttribute('aria-current', p===path ? 'page':'false');
  }
  const outlet = $('#outlet');
  outlet.innerHTML = '';
  (routes[path]||renderSetup)(outlet, force);
}

// ---------- Setup View ----------
function renderSetup(root) {
  root.appendChild(card(`
    <div style="display:flex;align-items:center;justify-content:space-between;gap:12px">
      <h2 style="margin:0">Site Photo + Grid</h2>
      <span class="pill"><span class="dot"></span> Live</span>
    </div>
  `,'span-12'));

  const controls = card(`
    <div class="row">
      <div class="field"><label>Job Name</label><input id="job-name" placeholder="Project / Section" value="${escapeHtml(state.job.name)}"></div>
      <div class="field"><label>Date</label><input id="job-date" type="date" value="${state.job.date}"></div>
      <div class="field"><label>Upload Site Photo</label><input id="site-photo" type="file" accept="image/*"></div>
      <div class="field"><label>Rows</label><input id="grid-rows" type="number" min="1" max="26" value="${state.grid.rows}"></div>
      <div class="field"><label>Cols</label><input id="grid-cols" type="number" min="1" max="200" value="${state.grid.cols}"></div>
      <div class="field"><label>Orientation</label>
        <select id="grid-orient">
          <option value="letters-rows" ${state.grid.orientation==='letters-rows'?'selected':''}>Letters = Rows, Numbers = Cols</option>
          <option value="numbers-rows" ${state.grid.orientation==='numbers-rows'?'selected':''}>Numbers = Rows, Letters = Cols</option>
        </select>
      </div>
      <div class="field"><label>Top Label Margin (px)</label><input id="margin-top" type="number" min="0" max="200" value="${state.grid.marginTop}"></div>
      <div class="field"><label>Left Label Margin (px)</label><input id="margin-left" type="number" min="0" max="200" value="${state.grid.marginLeft}"></div>
      <div class="field"><label>Header Shading</label>
        <select id="header-shade">
          <option value="1" ${state.grid.headerShade?'selected':''}>On</option>
          <option value="0" ${!state.grid.headerShade?'selected':''}>Off</option>
        </select>
      </div>
      <div class="field"><label>Label Color</label><input id="label-color" type="color" value="${state.grid.labelColor}"></div>
    </div>
    <div class="row" style="margin-top:6px;">
      <button class="btn" id="btn-start-roi">Start ROI</button>
      <button class="btn" id="btn-reset-roi">Reset ROI</button>
      <button class="btn primary" id="btn-save-grid">Save Grid</button>
    </div>
    <p class="muted" style="margin:8px 0 0">Tip: Drag to draw the grid area (ROI). Resize via corner handles. Labels render in the top/left margins you set.</p>
  `,'span-12');
  root.appendChild(controls);

  // Canvas preview
  const wrap = document.createElement('section');
  wrap.className = 'card span-12';
  wrap.innerHTML = `
    <div class="canvasWrap" id="wrap">
      <canvas id="cvs"></canvas>
      <!-- selection handles are absolutely positioned; created dynamically -->
    </div>
  `;
  root.appendChild(wrap);

  // Wire inputs
  $('#job-name').addEventListener('input', e => state.job.name = e.target.value);
  $('#job-date').addEventListener('input', e => state.job.date = e.target.value);
  $('#grid-rows').addEventListener('change', e => { state.grid.rows = clamp(+e.target.value,1,26); redraw(); });
  $('#grid-cols').addEventListener('change', e => { state.grid.cols = clamp(+e.target.value,1,200); redraw(); });
  $('#grid-orient').addEventListener('change', e => { state.grid.orientation = e.target.value; redraw(); });
  $('#margin-top').addEventListener('change', e => { state.grid.marginTop = clamp(+e.target.value,0,200); redraw(); });
  $('#margin-left').addEventListener('change', e => { state.grid.marginLeft = clamp(+e.target.value,0,200); redraw(); });
  $('#header-shade').addEventListener('change', e => { state.grid.headerShade = e.target.value==='1'; redraw(); });
  $('#label-color').addEventListener('change', e => { state.grid.labelColor = e.target.value; redraw(); });
  $('#site-photo').addEventListener('change', onPhotoSelected);
  $('#btn-start-roi').addEventListener('click', ()=> startROI());
  $('#btn-reset-roi').addEventListener('click', ()=> { if (!state.image) return; state.roi = {x:0,y:0,w:state.imgW,h:state.imgH}; redraw(true); });
  $('#btn-save-grid').addEventListener('click', ()=> {
    if (!state.image) return toast('Upload a site photo first', 'warn');
    if (!state.roi) return toast('Draw an ROI for the grid', 'warn');
    toast('Grid saved ✔️','ok');
  });

  // Drawing logic
  const cvs = $('#cvs'), ctx = cvs.getContext('2d');
  const wrapEl = $('#wrap'); wrapEl.style.minHeight = '320px'; // so it doesn’t collapse before image loads
  setupHiDPICanvas(cvs);

  // ROI selection via Pointer Events
  const sel = {
    active:false, mode:'idle', // 'draw' | 'move' | 'resize'
    startX:0, startY:0,
    x:0,y:0,w:0,h:0,
    handle:null
  };

  function onPhotoSelected(e){
    const f = e.target.files && e.target.files[0]; if(!f) return;
    const img = new Image(); img.onload = () => {
      state.image = img; state.imgW = img.naturalWidth; state.imgH = img.naturalHeight;
      state.roi = {x:0,y:0,w:state.imgW,h:state.imgH};
      redraw(true);
      toast('Photo loaded ✔️','ok');
    };
    img.onerror = () => toast('Failed to load image','err');
    img.src = URL.createObjectURL(f);
  }

  function startROI(){
    if(!state.image){ toast('Upload a site photo first','warn'); return; }
    sel.mode = 'draw';
    toast('Drag on the image to draw ROI');
  }

  function setupHiDPICanvas(canvas){
    const dpr = Math.max(1, window.devicePixelRatio||1);
    const rect = wrapEl.getBoundingClientRect();
    const cssW = Math.max(320, rect.width);
    const cssH = Math.max(240, rect.width * 0.6);
    canvas.style.width = cssW+'px';
    canvas.style.height = cssH+'px';
    canvas.width = Math.round(cssW * dpr);
    canvas.height = Math.round(cssH * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0); // scale drawing back to CSS pixels
  }

  function clientToImage(px,py){
    // map from canvas CSS pixels to image pixels
    const rect = cvs.getBoundingClientRect();
    const cx = px - rect.left, cy = py - rect.top;
    const scale = fitContainScale(state.imgW, state.imgH, rect.width, rect.height);
    const offX = (rect.width - state.imgW*scale)/2;
    const offY = (rect.height - state.imgH*scale)/2;
    const ix = (cx - offX) / scale, iy = (cy - offY) / scale;
    return {x: clamp(ix, 0, state.imgW), y: clamp(iy, 0, state.imgH)};
  }

  wrapEl.addEventListener('pointerdown', (e)=>{
    if(!state.image) return;
    wrapEl.setPointerCapture(e.pointerId);
    const {x,y} = clientToImage(e.clientX,e.clientY);
    const hit = hitHandle(x,y);
    if (sel.mode === 'draw'){
      sel.active = true; sel.startX = x; sel.startY = y; sel.x = x; sel.y = y; sel.w = 0; sel.h = 0; sel.handle=null;
    } else if (hit){
      sel.active = true; sel.mode = 'resize'; sel.handle = hit;
    } else if (pointInRect({x,y}, state.roi)){
      sel.active = true; sel.mode = 'move'; sel.startX = x; sel.startY = y;
    } else {
      sel.active = false;
    }
    e.preventDefault();
  });

  wrapEl.addEventListener('pointermove', (e)=>{
    if(!state.image || !sel.active) return;
    const {x,y} = clientToImage(e.clientX,e.clientY);
    if (sel.mode==='draw'){
      sel.x = Math.min(sel.startX, x);
      sel.y = Math.min(sel.startY, y);
      sel.w = Math.abs(x - sel.startX);
      sel.h = Math.abs(y - sel.startY);
      state.roi = normRect({x:sel.x,y:sel.y,w:sel.w,h:sel.h}, state);
      redraw();
    } else if (sel.mode==='move'){
      const dx = x - sel.startX, dy = y - sel.startY;
      sel.startX = x; sel.startY = y;
      state.roi.x = clamp(state.roi.x + dx, 0, state.imgW - state.roi.w);
      state.roi.y = clamp(state.roi.y + dy, 0, state.imgH - state.roi.h);
      redraw();
    } else if (sel.mode==='resize' && sel.handle){
      resizeROI(sel.handle, x,y);
      redraw();
    }
  }, {passive:true});

  ['pointerup','pointercancel','lostpointercapture'].forEach(ev =>
    wrapEl.addEventListener(ev, ()=>{ sel.active=false; if (sel.mode==='draw') sel.mode='idle'; }));

  function resizeROI(handle, x,y){
    const r = state.roi;
    if (handle.includes('w')) { const nx = clamp(x,0,r.x+r.w); r.w = (r.x+r.w) - nx; r.x = nx; }
    if (handle.includes('e')) { const nx = clamp(x,r.x, state.imgW); r.w = nx - r.x; }
    if (handle.includes('n')) { const ny = clamp(y,0,r.y+r.h); r.h = (r.y+r.h) - ny; r.y = ny; }
    if (handle.includes('s')) { const ny = clamp(y,r.y, state.imgH); r.h = ny - r.y; }
  }

  function redraw(forceSize=false){
    if (forceSize) setupHiDPICanvas(cvs);
    ctx.clearRect(0,0,cvs.width, cvs.height);
    if(!state.image) return drawCheckerboard(ctx, cvs);

    const rect = cvs.getBoundingClientRect();
    const scale = fitContainScale(state.imgW, state.imgH, rect.width, rect.height);
    const offX = (rect.width - state.imgW*scale)/2;
    const offY = (rect.height - state.imgH*scale)/2;

    // draw photo
    ctx.save();
    ctx.translate(offX, offY);
    ctx.scale(scale, scale);
    ctx.drawImage(state.image, 0,0, state.imgW, state.imgH);

    // ROI dim overlay
    ctx.fillStyle = 'rgba(0,0,0,.35)';
    ctx.fillRect(0,0,state.imgW,state.imgH);
    if (state.roi){
      ctx.clearRect(state.roi.x, state.roi.y, state.roi.w, state.roi.h);
      drawGrid(ctx, state); // grid inside ROI
      drawROIFrame(ctx, state.roi);
    }
    ctx.restore();

    // position handles in CSS space
    placeHandles();
  }

  function drawGrid(ctx, s){
    const {roi, grid} = s;
    // header shading bands
    if (grid.headerShade){
      ctx.fillStyle = 'rgba(12,18,32,.55)';
      if (grid.marginTop>0) ctx.fillRect(roi.x, roi.y - grid.marginTop, roi.w, grid.marginTop);
      if (grid.marginLeft>0) ctx.fillRect(roi.x - grid.marginLeft, roi.y, grid.marginLeft, roi.h);
    }
    // grid lines
    ctx.strokeStyle = 'rgba(255,255,255,.45)';
    ctx.lineWidth = 1;
    for (let c=0;c<=grid.cols;c++){
      const x = roi.x + c*(roi.w/grid.cols);
      ctx.beginPath(); ctx.moveTo(x, roi.y); ctx.lineTo(x, roi.y+roi.h); ctx.stroke();
    }
    for (let r=0;r<=grid.rows;r++){
      const y = roi.y + r*(roi.h/grid.rows);
      ctx.beginPath(); ctx.moveTo(roi.x, y); ctx.lineTo(roi.x+roi.w, y); ctx.stroke();
    }
    // labels
    const labelColor = grid.labelColor;
    const shadow = grid.labelShadow;
    const fontSize = Math.max(10, Math.min(18, Math.min(roi.w/grid.cols, roi.h/grid.rows) * 0.45));
    ctx.font = `600 ${fontSize}px Inter, system-ui, sans-serif`;
    ctx.textBaseline = 'middle'; ctx.textAlign = 'center';
    const rH = roi.h/grid.rows, cW = roi.w/grid.cols;

    // helper to stroke+fill for contrast
    function drawLabel(txt, x,y){
      ctx.lineWidth = Math.max(2, fontSize/6);
      ctx.strokeStyle = shadow;
      ctx.fillStyle = labelColor;
      ctx.strokeText(txt,x,y);
      ctx.fillText(txt,x,y);
    }

    if (grid.orientation==='letters-rows'){
      // top numbers for columns
      for (let c=1;c<=grid.cols;c++){
        drawLabel(String(c), roi.x + (c-0.5)*cW, roi.y - grid.marginTop/2);
      }
      // left letters for rows
      for (let r=1;r<=grid.rows;r++){
        drawLabel(letterFor(r), roi.x - grid.marginLeft/2, roi.y + (r-0.5)*rH);
      }
    } else {
      // top letters for columns
      for (let c=1;c<=grid.cols;c++){
        drawLabel(letterFor(c), roi.x + (c-0.5)*cW, roi.y - grid.marginTop/2);
      }
      // left numbers for rows
      for (let r=1;r<=grid.rows;r++){
        drawLabel(String(r), roi.x - grid.marginLeft/2, roi.y + (r-0.5)*rH);
      }
    }
  }

  function drawROIFrame(ctx, r){
    ctx.save();
    ctx.strokeStyle = '#22d3ee';
    ctx.lineWidth = 2;
    ctx.strokeRect(r.x, r.y, r.w, r.h);
    ctx.restore();
  }

  function placeHandles(){
    // remove old
    $$('.handle', wrapEl).forEach(h => h.remove());
    if (!state.roi || !state.image) return;
    const rect = cvs.getBoundingClientRect();
    const scale = fitContainScale(state.imgW, state.imgH, rect.width, rect.height);
    const offX = (rect.width - state.imgW*scale)/2;
    const offY = (rect.height - state.imgH*scale)/2;
    const r = state.roi;
    const points = {nw:[r.x,r.y], ne:[r.x+r.w,r.y], sw:[r.x,r.y+r.h], se:[r.x+r.w,r.y+r.h]};
    for (const [name,[ix,iy]] of Object.entries(points)){
      const hx = offX + ix*scale - 6, hy = offY + iy*scale - 6;
      const h = document.createElement('div');
      h.className = 'handle'; h.dataset.dir = name;
      h.style.left = hx+'px'; h.style.top = hy+'px';
      wrapEl.appendChild(h);
      h.addEventListener('pointerdown', (e)=>{ sel.mode='resize'; sel.active=true; sel.handle=name; wrapEl.setPointerCapture(e.pointerId); e.preventDefault(); });
    }
  }

  function hitHandle(ix,iy){
    // hit test in image space around 8x8px corners
    const r = state.roi; if(!r) return null;
    const h = 8;
    if (near(ix,iy,r.x,r.y,h)) return 'nw';
    if (near(ix,iy,r.x+r.w,r.y,h)) return 'ne';
    if (near(ix,iy,r.x,r.y+r.h,h)) return 'sw';
    if (near(ix,iy,r.x+r.w,r.y+r.h,h)) return 'se';
    return null;
  }

  function drawCheckerboard(ctx,c){
    const s=20; ctx.fillStyle='#0d1426'; ctx.fillRect(0,0,c.width,c.height);
    ctx.save(); ctx.scale(window.devicePixelRatio||1, window.devicePixelRatio||1);
    for(let y=0;y<c.height;y+=s) for(let x=0;x<c.width;x+=s) if(((x+y)/s)%2===0){
      ctx.fillStyle='#0a1020'; ctx.fillRect(x,y,s,s);
    }
    ctx.restore();
  }

  // initial draw
  redraw(true);
}

// ---------- Entry View ----------
function renderEntry(root){
  root.appendChild(card(`<h2 style="margin:0 0 8px">RCC Results Entry</h2>`,'span-12'));

  const form = card(`
    <div class="row">
      <div class="field"><label>Location</label><input id="t-loc" placeholder="Station / Offset"></div>
      <div class="field"><label>Wet Density (pcf)</label><input id="t-wd" type="number" inputmode="decimal" step="0.1"></div>
      <div class="field"><label>Moisture (%)</label><input id="t-moist" type="number" inputmode="decimal" step="0.1"></div>
      <div class="field"><label>Grid Coord (e.g., A3)</label><input id="t-grid" placeholder="A3 / B12"></div>
    </div>
    <div class="row" style="margin-top:8px">
      <button class="btn primary" id="t-add">Add Test</button>
      <button class="btn" id="t-clear">Clear</button>
    </div>
    <p class="muted" style="margin:8px 0 0">Grid coord checks your current grid settings and ROI; markers are auto-plotted in Summary.</p>
  `,'span-12');
  root.appendChild(form);

  $('#t-add').addEventListener('click', ()=>{
    const location = $('#t-loc').value.trim();
    const wd = parseFloat($('#t-wd').value);
    const moist = parseFloat($('#t-moist').value);
    const coordTxt = $('#t-grid').value.trim().toUpperCase();
    const v = validateCoord(coordTxt, state.grid);
    if (coordTxt && !v.ok) { toast(v.msg,'warn'); return; }

    let row=null,col=null,x=null,y=null;
    if (coordTxt){
      const rc = parseCoord(coordTxt, state.grid);
      if (!rc) { toast('Invalid coord','warn'); return; }
      row = rc.row; col = rc.col;
      const p = gridCellCenterPx(row,col, state.roi, state.grid);
      if (!p) { toast('Coord outside ROI or grid','warn'); return; }
      x = p.x; y = p.y;
    }
    const id = cryptoId();
    const num = state.tests.length + 1;
    state.tests.push({id,num,location,wd:isFinite(wd)?wd:null,moist:isFinite(moist)?moist:null,coord:coordTxt,row,col,x,y});
    toast(`Test #${num} added ✔️`,'ok');
    // clear
    $('#t-loc').value=''; $('#t-wd').value=''; $('#t-moist').value=''; $('#t-grid').value='';
  });

  $('#t-clear').addEventListener('click', ()=>{
    $('#t-loc').value=''; $('#t-wd').value=''; $('#t-moist').value=''; $('#t-grid').value='';
  });
}

// ---------- Summary View ----------
function renderSummary(root){
  root.appendChild(card(`
    <div style="display:flex;align-items:center;justify-content:space-between;gap:12px">
      <h2 style="margin:0">Summary</h2>
      <div class="pill"><span class="dot"></span> ${escapeHtml(state.job.name||'Untitled Job')} • ${state.job.date}</div>
    </div>
  `,'span-12'));

  // Annotated preview
  const prev = document.createElement('section');
  prev.className = 'card span-12';
  prev.innerHTML = `
    <div class="row" style="justify-content:space-between;align-items:center;margin-bottom:8px">
      <strong>Annotated Site Photo</strong>
      <div>
        <button class="btn" id="btn-regen">Rebuild Image</button>
        <button class="btn" id="btn-save-png">Save PNG</button>
        <button class="btn" id="btn-save-pdf">Save PDF</button>
        <button class="btn" id="btn-save-csv">Save CSV</button>
      </div>
    </div>
    <div class="canvasWrap">
      <canvas id="anno"></canvas>
    </div>
  `;
  root.appendChild(prev);

  // Table
  const table = document.createElement('section');
  table.className = 'card span-12';
  table.innerHTML = `
    <h3 style="margin:0 0 8px">Tests</h3>
    <div style="overflow:auto; max-height:420px">
      <table id="sum-table">
        <thead><tr>
          <th style="width:60px">#</th>
          <th>Location</th>
          <th style="width:140px">Wet Density</th>
          <th style="width:140px">Moisture</th>
          <th style="width:120px">Grid</th>
          <th style="width:80px"></th>
        </tr></thead>
        <tbody></tbody>
      </table>
    </div>
  `;
  root.appendChild(table);

  // Canvas + export wiring
  const cvs = $('#anno'), ctx = cvs.getContext('2d');
  setupHiDPICanvas(cvs, 900);

  function setupHiDPICanvas(canvas, cssW=900){
    const dpr = Math.max(1, window.devicePixelRatio||1);
    const cssH = Math.round(cssW * 0.62);
    canvas.style.width = cssW+'px';
    canvas.style.height = cssH+'px';
    canvas.width = Math.round(cssW * dpr);
    canvas.height = Math.round(cssH * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }

  function buildAnnotated(){
    ctx.clearRect(0,0,cvs.width,cvs.height);
    if (!state.image){ drawNoImage(ctx,cvs); return; }
    // Fit entire image into canvas, then draw ROI grid+labels and markers
    const rect = cvs.getBoundingClientRect();
    const scale = fitContainScale(state.imgW, state.imgH, rect.width, rect.height);
    const offX = (rect.width - state.imgW*scale)/2;
    const offY = (rect.height - state.imgH*scale)/2;
    ctx.save();
    ctx.translate(offX, offY);
    ctx.scale(scale, scale);
    ctx.drawImage(state.image, 0,0, state.imgW, state.imgH);
    if (state.roi) drawGrid(ctx, state);
    // markers
    drawMarkers(ctx, state, scale=1);
    ctx.restore();
  }

  function drawNoImage(ctx, c){
    ctx.fillStyle='#0e1626'; ctx.fillRect(0,0,c.width,c.height);
    ctx.fillStyle='#8aa0b6'; ctx.font='600 18px Inter, system-ui'; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText('Upload a site photo in Job Setup to see the annotated preview', c.width/2, c.height/2);
  }

  function drawMarkers(ctx, s){
    const fontSize = 14;
    ctx.font = `700 ${fontSize}px Inter, system-ui, sans-serif`;
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    s.tests.forEach(t =>{
      if (t && isFinite(t.x) && isFinite(t.y)){
        // pin
        ctx.beginPath();
        ctx.fillStyle = '#22d3ee';
        ctx.strokeStyle = '#0b1220';
        ctx.lineWidth = 2;
        ctx.arc(t.x, t.y, 10, 0, Math.PI*2);
        ctx.fill(); ctx.stroke();
        // number
        ctx.fillStyle = '#0b1220';
        ctx.fillText(String(t.num), t.x, t.y+0.5);
        ctx.strokeStyle = 'rgba(255,255,255,.85)';
        ctx.lineWidth = 3;
        ctx.strokeText(String(t.num), t.x, t.y+0.5);
        ctx.fillStyle = '#ffffff';
        ctx.fillText(String(t.num), t.x, t.y+0.5);
      }
    });
  }

  $('#btn-regen').addEventListener('click', ()=> { buildAnnotated(); toast('Image rebuilt'); });
  $('#btn-save-png').addEventListener('click', ()=> {
    buildAnnotated();
    const a = document.createElement('a');
    a.download = safeName(state.job.name||'rcc') + '-annotated.png';
    a.href = cvs.toDataURL('image/png');
    a.click();
  });
  $('#btn-save-pdf').addEventListener('click', async ()=>{
    buildAnnotated();
    const { jsPDF } = window.jspdf;
    const pdf = new jsPDF({orientation:'landscape', unit:'pt', format:'a4'});
    const imgData = cvs.toDataURL('image/png');
    const pgW = pdf.internal.pageSize.getWidth(), pgH = pdf.internal.pageSize.getHeight();
    // image
    const m = 28, iw = pgW - m*2, ih = (cvs.height/cvs.width)*iw;
    pdf.setFont('helvetica','bold'); pdf.setFontSize(14);
    pdf.text((state.job.name||'RCC Pro Report') + ' — ' + state.job.date, m, 26);
    pdf.addImage(imgData, 'PNG', m, 40, iw, ih, undefined, 'FAST');
    // table (simple)
    let y = 60 + ih;
    pdf.setFontSize(12);
    pdf.text('Tests', m, y); y+=6;
    pdf.setFontSize(10);
    const headers = ['#','Location','Wet Density','Moisture','Grid'];
    const colW = [22, 220, 100, 90, 60];
    y+=10;
    // header
    headers.forEach((h,i)=> pdf.text(h, m + colW.slice(0,i).reduce((a,b)=>a+b,0), y));
    y+=12;
    state.tests.forEach(t=>{
      const row = [
        String(t.num),
        t.location||'',
        isFinite(t.wd)? String(t.wd):'',
        isFinite(t.moist)? String(t.moist):'',
        t.coord||''
      ];
      row.forEach((val,i)=> pdf.text(val, m + colW.slice(0,i).reduce((a,b)=>a+b,0), y));
      y+=12;
      if (y > pgH - 40){ pdf.addPage(); y=40; }
    });
    pdf.save(safeName(state.job.name||'rcc') + '-report.pdf');
  });
  $('#btn-save-csv').addEventListener('click', ()=>{
    const header = ['num','location','wet_density','moisture','grid'];
    const csv = [header.join(',')].concat(
      state.tests.map(t => [t.num,t.location,t.wd??'',t.moist??'',t.coord??''].map(v=>JSON.stringify(v)).join(','))
    ).join('\n');
    const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href=url; a.download = safeName(state.job.name||'rcc') + '.csv'; a.click();
    URL.revokeObjectURL(url);
  });

  // Build table
  const tbody = $('#sum-table tbody');
  function rebuildTable(){
    tbody.innerHTML = '';
    for (const t of state.tests){
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td>${t.num}</td>
        <td><input value="${escapeHtml(t.location||'')}" data-k="location"></td>
        <td><input type="number" step="0.1" value="${isFinite(t.wd)?t.wd:''}" data-k="wd"></td>
        <td><input type="number" step="0.1" value="${isFinite(t.moist)?t.moist:''}" data-k="moist"></td>
        <td><input value="${escapeHtml(t.coord||'')}" data-k="coord"></td>
        <td><button class="btn danger" data-del="${t.id}">Delete</button></td>
      `;
      // events
      tr.querySelectorAll('input').forEach(inp=>{
        inp.addEventListener('keydown', e=>{ if (e.key==='Enter') inp.blur(); });
        inp.addEventListener('blur', ()=>{
          const k = inp.dataset.k;
          const v = inp.type==='number' ? (inp.value===''?null:parseFloat(inp.value)) : inp.value.trim();
          if (k==='coord'){
            if (v){
              const val = validateCoord(v, state.grid);
              if (!val.ok){ toast(val.msg,'warn'); inp.focus(); return; }
              const rc = parseCoord(v, state.grid);
              const p = gridCellCenterPx(rc.row, rc.col, state.roi, state.grid);
              Object.assign(t, {coord:v.toUpperCase(), row:rc.row, col:rc.col, x:p?.x ?? null, y:p?.y ?? null});
            } else {
              Object.assign(t, {coord:'', row:null,col:null,x:null,y:null});
            }
          } else {
            t[k] = v;
          }
          buildAnnotated();
        });
      });
      tr.querySelector('button[data-del]').addEventListener('click', ()=>{
        const idx = state.tests.findIndex(x=>x.id===t.id);
        if (idx>=0){ state.tests.splice(idx,1); renumber(); rebuildTable(); buildAnnotated(); }
      });
      tbody.appendChild(tr);
    }
  }
  function renumber(){ state.tests.forEach((t,i)=> t.num = i+1); }

  rebuildTable();
  buildAnnotated();
}

// ---------- Helpers ----------
function card(inner, span='span-12'){ const c=document.createElement('section'); c.className='card '+span; c.innerHTML=inner; return c; }
function clamp(n,min,max){ return Math.min(max, Math.max(min,n)); }
function near(x,y,tx,ty,h=8){ return Math.abs(x-tx)<=h && Math.abs(y-ty)<=h; }
function pointInRect(p,r){ return p.x>=r.x && p.x<=r.x+r.w && p.y>=r.y && p.y<=r.y+r.h; }
function normRect(r, s){ // clamp to image bounds, min size
  const min=10;
  const x = clamp(r.x,0,s.imgW), y = clamp(r.y,0,s.imgH);
  const w = clamp(r.w,0,s.imgW - x), h = clamp(r.h,0,s.imgH - y);
  return {x, y, w: Math.max(w,min), h: Math.max(h,min)};
}
function fitContainScale(iw,ih,cw,ch){ const sx=cw/iw, sy=ch/ih; return Math.min(sx,sy); }
function letterFor(n){ // 1->A ... 26->Z
  const i = clamp(n,1,26); return String.fromCharCode(64+i);
}
function escapeHtml(s=''){ return s.replace(/[&<>"']/g, m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m])); }
function safeName(s){ return s.toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/(^-|-$)/g,''); }
function cryptoId(){ return 't'+Math.random().toString(36).slice(2,9); }

function validateCoord(txt, grid){
  const t = (txt||'').trim().toUpperCase();
  if (!t) return {ok:true};
  // accept A12 or 12A regardless, then interpret by orientation
  const m = t.match(/^([A-Z]{1})(\d{1,3})$|^(\d{1,3})([A-Z]{1})$/);
  if (!m) return {ok:false,msg:'Use A1..Z200 (one letter + numbers)'};
  let row=null, col=null;
  if (grid.orientation==='letters-rows'){
    // rows letter, cols number
    if (m[1]){ row = m[1].charCodeAt(0)-64; col = parseInt(m[2],10); }
    else { row = m[4].charCodeAt(0)-64; col = parseInt(m[3],10); }
  } else {
    // rows number, cols letter
    if (m[1]){ row = parseInt(m[2],10); col = m[1].charCodeAt(0)-64; }
    else { row = parseInt(m[3],10); col = m[4].charCodeAt(0)-64; }
  }
  if (!(row>=1 && row<=26)) return {ok:false,msg:'Row out of range (A..Z or 1..rows)'};
  if (!(col>=1 && col<=200)) return {ok:false,msg:'Column out of range (1..cols)'};
  if (row> (grid.orientation==='letters-rows' ? grid.rows : grid.rows)) return {ok:false,msg:`Row exceeds grid (${grid.rows})`};
  if (col> (grid.orientation==='letters-rows' ? grid.cols : grid.cols)) return {ok:false,msg:`Column exceeds grid (${grid.cols})`};
  return {ok:true};
}

function parseCoord(txt, grid){
  const t = (txt||'').trim().toUpperCase();
  const m = t.match(/^([A-Z]{1})(\d{1,3})$|^(\d{1,3})([A-Z]{1})$/);
  if (!m) return null;
  if (grid.orientation==='letters-rows'){
    const row = (m[1]?m[1]:m[4]).charCodeAt(0)-64;
    const col = parseInt((m[2]?m[2]:m[3]),10);
    return {row, col};
  } else {
    const row = parseInt((m[2]?m[2]:m[3]),10);
    const col = (m[1]?m[1]:m[4]).charCodeAt(0)-64;
    return {row, col};
  }
}

function gridCellCenterPx(row, col, roi, grid){
  if (!roi) return null;
  if (!(row>=1 && col>=1)) return null;
  if (row>grid.rows || col>grid.cols) return null;
  // map cell center in image pixel space
  const cw = roi.w / grid.cols, rh = roi.h / grid.rows;
  const x = roi.x + (col - 0.5) * cw;
  const y = roi.y + (row - 0.5) * rh;
  return {x,y};
}

// Reuse drawGrid in Summary too
function drawGrid(ctx, s){ // duplicated signature used by both views
  const {roi, grid} = s;
  if (!roi) return;
  if (grid.headerShade){
    ctx.fillStyle = 'rgba(12,18,32,.55)';
    if (grid.marginTop>0) ctx.fillRect(roi.x, roi.y - grid.marginTop, roi.w, grid.marginTop);
    if (grid.marginLeft>0) ctx.fillRect(roi.x - grid.marginLeft, roi.y, grid.marginLeft, roi.h);
  }
  ctx.strokeStyle = 'rgba(255,255,255,.45)'; ctx.lineWidth = 1;
  for (let c=0;c<=grid.cols;c++){
    const x = roi.x + c*(roi.w/grid.cols);
    ctx.beginPath(); ctx.moveTo(x, roi.y); ctx.lineTo(x, roi.y+roi.h); ctx.stroke();
  }
  for (let r=0;r<=grid.rows;r++){
    const y = roi.y + r*(roi.h/grid.rows);
    ctx.beginPath(); ctx.moveTo(roi.x, y); ctx.lineTo(roi.x+roi.w, y); ctx.stroke();
  }
  const labelColor = grid.labelColor, shadow = grid.labelShadow;
  const fontSize = Math.max(10, Math.min(18, Math.min(roi.w/grid.cols, roi.h/grid.rows) * 0.45));
  ctx.font = `600 ${fontSize}px Inter, system-ui, sans-serif`;
  ctx.textBaseline = 'middle'; ctx.textAlign = 'center';
  const rH = roi.h/grid.rows, cW = roi.w/grid.cols;

  function drawLabel(txt, x,y){
    ctx.lineWidth = Math.max(2, fontSize/6);
    ctx.strokeStyle = shadow;
    ctx.fillStyle = labelColor;
    ctx.strokeText(txt,x,y);
    ctx.fillText(txt,x,y);
  }
  if (grid.orientation==='letters-rows'){
    for (let c=1;c<=grid.cols;c++) drawLabel(String(c), roi.x + (c-0.5)*cW, roi.y - grid.marginTop/2);
    for (let r=1;r<=grid.rows;r++) drawLabel(letterFor(r), roi.x - grid.marginLeft/2, roi.y + (r-0.5)*rH);
  } else {
    for (let c=1;c<=grid.cols;c++) drawLabel(letterFor(c), roi.x + (c-0.5)*cW, roi.y - grid.marginTop/2);
    for (let r=1;r<=grid.rows;r++) drawLabel(String(r), roi.x - grid.marginLeft/2, roi.y + (r-0.5)*rH);
  }
}

// Export menu (simple)
function showExportMenu(){
  const path = (location.hash.replace('#','') || '/setup');
  if (path !== '/summary'){ location.hash = '#/summary'; setTimeout(()=> toast('Open Summary to export')), 0; return; }
  toast('Use Save PNG / PDF / CSV in Summary ✔️','ok');
}
</script>
</body>
</html>
