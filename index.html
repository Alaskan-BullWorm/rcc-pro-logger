<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
<title>RCC Pro — Logger</title>
<meta name="color-scheme" content="dark light"/>
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
<style>
:root{
  --bg:#0b1220; --panel:#0f172a; --line:rgba(148,163,184,.22);
  --muted:#93a0b3; --text:#e6e8eb; --brand:#22d3ee; --brand2:#0891b2;
  --ok:#34d399; --warn:#fbbf24; --err:#f87171; --radius:14px; --shadow:0 12px 36px rgba(0,0,0,.35);
}
*{box-sizing:border-box}
html,body{height:100%}
body{margin:0;background:
  radial-gradient(1000px 460px at -10% -10%, rgba(34,211,238,.06), transparent 60%),
  radial-gradient(1000px 460px at 120% 10%, rgba(56,189,248,.06), transparent 60%),
  var(--bg);
  color:var(--text); font:15px/1.45 Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial;
}
/* Header */
header{position:sticky;top:0;z-index:1000;backdrop-filter:blur(10px) saturate(140%);
  background:linear-gradient(to bottom,rgba(16,24,38,.92),rgba(16,24,38,.6)); border-bottom:1px solid var(--line)}
.nav{max-width:1200px;margin:0 auto;padding:10px 14px;display:grid;grid-template-columns:auto 1fr auto;gap:10px;align-items:center}
.brand{display:inline-flex;gap:10px;align-items:center;font-weight:700}
.logo{width:28px;height:28px;border-radius:8px;background:linear-gradient(135deg,var(--brand),var(--brand2));
  box-shadow:inset 0 0 10px rgba(255,255,255,.28),0 6px 18px rgba(8,145,178,.45)}
.tabs{justify-self:center;display:flex;gap:8px;background:rgba(148,163,184,.12);border:1px solid var(--line);border-radius:999px;padding:4px}
.tabs a{color:var(--muted);text-decoration:none;padding:8px 12px;border-radius:999px}
.tabs a[aria-current="page"], .tabs a:focus-visible, .tabs a:hover{color:var(--text);background:linear-gradient(180deg,rgba(34,211,238,.16),rgba(8,145,178,.12))}
.actions{justify-self:end;display:flex;gap:8px}
.btn{border:1px solid var(--line);background:linear-gradient(180deg,rgba(2,6,23,.6),rgba(2,6,23,.3));color:var(--text);
  padding:10px 12px;border-radius:12px;cursor:pointer;touch-action:manipulation}
.btn.primary{border-color:rgba(34,211,238,.45);background:linear-gradient(180deg,rgba(34,211,238,.18),rgba(8,145,178,.14))}
.btn.ghost{background:transparent}
.btn.danger{border-color:rgba(248,113,113,.45)}
.btn:disabled{opacity:.6;cursor:not-allowed}

/* Layout */
main{max-width:1200px;margin:16px auto 100px;padding:0 14px}
.grid{display:grid;gap:12px;grid-template-columns:1fr}
@media(min-width:900px){ .grid{grid-template-columns:repeat(12,1fr)} }
.card{grid-column:1 / -1;background:linear-gradient(180deg,rgba(255,255,255,.05),rgba(255,255,255,.03));border:1px solid var(--line);
  border-radius:var(--radius);box-shadow:var(--shadow);padding:14px}
@media(min-width:900px){ .span-4{grid-column:span 4}.span-6{grid-column:span 6}.span-8{grid-column:span 8}.span-12{grid-column:span 12} }
h2,h3{margin:0 0 8px}
.muted{color:var(--muted)}
.row{display:flex;flex-wrap:wrap;gap:10px;align-items:center}
.field{display:flex;flex-direction:column;gap:6px;flex:1 1 160px;min-width:160px}
.field label{font-size:12px;color:var(--muted)}
input,select,textarea{border:1px solid var(--line);background:#0e1626;color:var(--text);border-radius:10px;padding:10px 12px}
textarea{min-height:80px;resize:vertical}
.small{font-size:12px}
.badge{display:inline-flex;gap:6px;align-items:center;font-size:12px;color:var(--muted)}
.dot{width:8px;height:8px;border-radius:50%;background:var(--ok);box-shadow:0 0 10px var(--ok)}

/* Canvas / ROI & Crop (Pointer Events) */
.canvasWrap{position:relative;border:1px solid var(--line);border-radius:12px;overflow:hidden;background:#091124;touch-action:none}
canvas{display:block;width:100%;height:auto}
.handle{position:absolute;width:14px;height:14px;border:2px solid #fff;border-radius:3px;background:rgba(0,0,0,.35);box-shadow:0 0 0 1px rgba(0,0,0,.5)}

/* Sticky action bar */
.stickyBar{position:fixed;left:0;right:0;bottom:0;z-index:900;background:linear-gradient(to top,rgba(16,24,38,.96),rgba(16,24,38,.6));
  border-top:1px solid var(--line);padding:8px 12px}
.stickyBar .wrap{max-width:1200px;margin:0 auto;display:flex;gap:8px;justify-content:space-between}
.stickyBar .wrap .group{display:flex;gap:8px;flex-wrap:wrap}

/* Table */
table{width:100%;border-collapse:collapse}
th,td{padding:10px;border-bottom:1px solid rgba(148,163,184,.15);text-align:left}
th{background:rgba(148,163,184,.12);position:sticky;top:0}

/* Toast */
.toast{position:fixed;right:12px;bottom:64px;background:#0b1220;border:1px solid var(--line);border-radius:12px;padding:10px 12px;min-width:260px;display:none}
.toast.show{display:block;animation:pop .2s ease-out}
@keyframes pop{from{transform:translateY(6px);opacity:0}to{transform:translateY(0);opacity:1}}
.sr-only{position:absolute;width:1px;height:1px;clip-path:inset(50%);overflow:hidden;white-space:nowrap}
</style>
</head>
<body>
<header>
  <div class="nav">
    <div class="brand"><div class="logo" aria-hidden="true"></div><span>RCC <span style="opacity:.75">Pro</span></span></div>
    <nav class="tabs" role="tablist" aria-label="Primary">
      <a id="tab-setup" href="#/setup" role="tab" aria-selected="true">Setup</a>
      <a id="tab-entry" href="#/entry" role="tab">Entry</a>
      <a id="tab-summary" href="#/summary" role="tab">Summary</a>
    </nav>
    <div class="actions">
      <button class="btn" id="btn-refresh" title="Refresh">↻</button>
      <button class="btn primary" id="btn-export">Export ▾</button>
    </div>
  </div>
</header>

<main><div id="outlet" class="grid"></div></main>

<!-- Sticky actions -->
<div class="stickyBar">
  <div class="wrap">
    <div class="group">
      <button class="btn" id="bar-prev">◀ Prev</button>
      <button class="btn" id="bar-next">Next ▶</button>
      <button class="btn primary" id="bar-update">Update Test</button>
    </div>
    <div class="group">
      <button class="btn" id="bar-gps">Use Current Location</button>
      <button class="btn" id="bar-ocr">Scan Gauge (OCR)</button>
      <button class="btn" id="bar-notes-ocr">Notes OCR</button>
    </div>
  </div>
</div>

<!-- Hidden file inputs -->
<input id="ocr-file" type="file" accept="image/*" capture="environment" class="sr-only" />
<input id="notes-file" type="file" accept="image/*" capture="environment" class="sr-only" />

<div id="toast" class="toast" role="status" aria-live="polite"></div>

<!-- Vendors -->
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@5.1.0/dist/tesseract.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>

<script>
/* ===========================================================
   RCC Pro — mobile/desktop logger with Grid, Crop, OCR, Export
   =========================================================== */

/* ---------- Utilities ---------- */
const $ = (q, root=document)=>root.querySelector(q);
const $$ = (q, root=document)=>Array.from(root.querySelectorAll(q));
const on = (el, ev, fn, opts)=>el.addEventListener(ev, fn, opts||false);
const toast = (msg, kind='info')=>{
  const t = $('#toast'); t.textContent = msg;
  t.style.borderColor = {info:'var(--line)', ok:'rgba(16,185,129,.45)', warn:'rgba(245,158,11,.45)', err:'rgba(244,63,94,.45)'}[kind] || 'var(--line)';
  t.classList.add('show'); clearTimeout(t._timer); t._timer=setTimeout(()=>t.classList.remove('show'), 2400);
};
const clamp = (n,min,max)=>Math.min(max, Math.max(min,n));
const fitContainScale = (iw,ih,cw,ch)=>Math.min(cw/iw, ch/ih);
const escapeHtml = (s='')=>s.replace(/[&<>"']/g, m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m]));
const safeName = (s)=> (s||'').toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/(^-|-$)/g,'');
const cryptoId = ()=> 't'+Math.random().toString(36).slice(2,9);
const isNum = (x)=> Number.isFinite(x);
const toNum = (v)=> { const n=parseFloat(v); return isNum(n)?n:null; };

/* ---------- State ---------- */
const state = {
  job: {
    name:'', date:new Date().toISOString().slice(0,10),
    jobAddress:'', overallDepth:null, // <-- requested
    mileage:null, mileageStatus:'idle', gps:null
  },
  image:null, imgW:0, imgH:0, originalImageDataUrl:null,
  roi:null,              // grid ROI (image pixels)
  crop:null,             // crop rectangle (image pixels) in crop mode
  grid:{ rows:12, cols:12, orientation:'letters-rows', marginTop:28, marginLeft:28,
         headerShade:true, labelColor:'#ffffff', labelShadow:'#000000', dim:0.25,
         brightness:100, contrast:100, saturation:100 },
  tests: [],             // {id,num,location,wd,moist,coord,row,col,x,y,notes}
  cursor:null
};

/* ---------- Router ---------- */
const routes = { '/setup': renderSetup, '/entry': renderEntry, '/summary': renderSummary };
window.addEventListener('hashchange', onRoute);
window.addEventListener('DOMContentLoaded', () => {
  bindGlobalBar();
  onRoute(true);
  $('#btn-refresh').addEventListener('click', ()=>{ onRoute(true); toast('Refreshed'); });
  $('#btn-export').addEventListener('click', ()=>{ if((location.hash.replace('#','')||'/setup')!=='/summary') location.hash='#/summary'; toast('Export from Summary ✔️','ok'); });
});

/* ---------- Views ---------- */
function onRoute(force=false){
  const path = location.hash.replace('#','') || '/setup';
  for (const [p,id] of Object.entries({'/setup':'tab-setup','/entry':'tab-entry','/summary':'tab-summary'})){
    const el = $('#'+id); if (el) el.setAttribute('aria-current', p===path ? 'page' : 'false');
  }
  const outlet = $('#outlet'); outlet.innerHTML='';
  (routes[path]||renderSetup)(outlet, force);
}

/* ===== Setup ===== */
function renderSetup(root){
  root.appendChild(card(`
    <div class="row" style="justify-content:space-between">
      <h2>Job Setup</h2>
      <span class="badge"><span class="dot"></span> Ready</span>
    </div>
  `,'span-12'));

  // Job + Mileage
  root.appendChild(card(`
    <div class="row">
      <div class="field"><label>Job Name</label><input id="job-name" placeholder="Project / Section" value="${escapeHtml(state.job.name)}"></div>
      <div class="field"><label>Date</label><input id="job-date" type="date" value="${state.job.date}"></div>
      <div class="field"><label>Job Address</label><input id="job-addr" placeholder="Street, City, State" value="${escapeHtml(state.job.jobAddress)}"></div>
      <div class="field"><label>Overall Depth (in.)</label><input id="job-depth" type="number" min="0" step="0.1" value="${isNum(state.job.overallDepth)?state.job.overallDepth:''}" placeholder="e.g., 8.0"></div>
    </div>
    <div class="row">
      <button class="btn" id="btn-mileage">Compute Round-Trip Mileage (GCI ↔ Job)</button>
      <span class="muted" id="mile-status">${mileageLabel()}</span>
    </div>
  `,'span-12'));

  // Photo + Grid controls
  root.appendChild(card(`
    <h3>Site Photo & Grid</h3>
    <div class="row">
      <div class="field"><label>Upload Site Photo</label><input id="site-photo" type="file" accept="image/*"></div>
      <div class="field"><label>Dim Grid Overlay (%)</label><input id="grid-dim" type="range" min="0" max="70" value="${Math.round(state.grid.dim*100)}"><span class="small muted">${Math.round(state.grid.dim*100)}%</span></div>
      <div class="field"><label>Brightness</label><input id="img-br" type="range" min="50" max="200" value="${state.grid.brightness}"></div>
      <div class="field"><label>Contrast</label><input id="img-ct" type="range" min="50" max="200" value="${state.grid.contrast}"></div>
      <div class="field"><label>Saturation</label><input id="img-sa" type="range" min="50" max="200" value="${state.grid.saturation}"></div>
    </div>
    <div class="row">
      <div class="field"><label>Rows</label><input id="grid-rows" type="number" min="1" max="26" value="${state.grid.rows}"></div>
      <div class="field"><label>Cols</label><input id="grid-cols" type="number" min="1" max="200" value="${state.grid.cols}"></div>
      <div class="field"><label>Orientation</label>
        <select id="grid-orient">
          <option value="letters-rows" ${state.grid.orientation==='letters-rows'?'selected':''}>Letters = Rows, Numbers = Cols</option>
          <option value="numbers-rows" ${state.grid.orientation==='numbers-rows'?'selected':''}>Numbers = Rows, Letters = Cols</option>
        </select>
      </div>
      <div class="field"><label>Top Label Margin (px)</label><input id="margin-top" type="number" min="0" max="200" value="${state.grid.marginTop}"></div>
      <div class="field"><label>Left Label Margin (px)</label><input id="margin-left" type="number" min="0" max="200" value="${state.grid.marginLeft}"></div>
      <div class="field"><label>Header Shading</label>
        <select id="header-shade"><option value="1" ${state.grid.headerShade?'selected':''}>On</option><option value="0" ${!state.grid.headerShade?'selected':''}>Off</option></select>
      </div>
    </div>
    <div class="row" style="margin-top:6px">
      <button class="btn" id="btn-start-roi">Draw Grid Area</button>
      <button class="btn" id="btn-reset-roi">Reset Grid Area</button>
      <button class="btn primary" id="btn-save-grid">Save Grid</button>
      <span class="muted small">Grid shows on Entry & Summary.</span>
    </div>
    <div class="row" style="margin-top:6px">
      <button class="btn" id="btn-start-crop">Start Crop</button>
      <button class="btn" id="btn-apply-crop">Apply Crop</button>
      <button class="btn" id="btn-reset-photo">Reset Photo</button>
      <span class="muted small">Crop changes the base image; grid re-anchors automatically.</span>
    </div>
  `,'span-12'));

  // Canvas preview with photo underlay, grid overlay, and ROI/crop rectangles
  const preview = document.createElement('section'); preview.className='card span-12';
  preview.innerHTML = `<div class="canvasWrap" id="wrap"><canvas id="cvs"></canvas></div>`;
  root.appendChild(preview);

  // Wire job basics
  on($('#job-name'),'input',e=>state.job.name=e.target.value);
  on($('#job-date'),'input',e=>state.job.date=e.target.value);
  on($('#job-addr'),'input',e=>state.job.jobAddress=e.target.value);
  on($('#job-depth'),'input',e=>state.job.overallDepth=toNum(e.target.value));

  // Mileage
  on($('#btn-mileage'),'click', async ()=>{
    if(!state.job.jobAddress){ toast('Enter Job Address first','warn'); return; }
    $('#mile-status').textContent='Calculating…';
    try{
      const miles = await computeRoundTripMiles('GCI Westerville Ohio', state.job.jobAddress);
      state.job.mileage = miles; state.job.mileageStatus='ok';
      $('#mile-status').textContent = mileageLabel();
      toast(`Round-trip: ${miles.toFixed(1)} mi ✔️`,'ok');
    }catch(e){ console.error(e); state.job.mileageStatus='err'; $('#mile-status').textContent='Mileage: failed'; toast('Mileage lookup failed','err'); }
  });

  // Grid controls
  on($('#grid-rows'),'change',e=>{ state.grid.rows = clamp(+e.target.value,1,26); redraw(); });
  on($('#grid-cols'),'change',e=>{ state.grid.cols = clamp(+e.target.value,1,200); redraw(); });
  on($('#grid-orient'),'change',e=>{ state.grid.orientation = e.target.value; redraw(); });
  on($('#margin-top'),'change',e=>{ state.grid.marginTop = clamp(+e.target.value,0,200); redraw(); });
  on($('#margin-left'),'change',e=>{ state.grid.marginLeft = clamp(+e.target.value,0,200); redraw(); });
  on($('#header-shade'),'change',e=>{ state.grid.headerShade = e.target.value==='1'; redraw(); });

  // Photo adjustments + dim
  const dimRange = $('#grid-dim'); const dimLabel = dimRange.nextElementSibling;
  on(dimRange,'input', e=>{ state.grid.dim = +e.target.value/100; dimLabel.textContent = `${Math.round(state.grid.dim*100)}%`; redraw(); });
  on($('#img-br'),'input', e=>{ state.grid.brightness = +e.target.value; redraw(); });
  on($('#img-ct'),'input', e=>{ state.grid.contrast = +e.target.value; redraw(); });
  on($('#img-sa'),'input', e=>{ state.grid.saturation = +e.target.value; redraw(); });

  // Photo load
  on($('#site-photo'),'change', (e)=>{
    const f = e.target.files?.[0]; if(!f) return;
    const img = new Image();
    img.onload = ()=>{
      state.image = img; state.imgW=img.naturalWidth; state.imgH=img.naturalHeight;
      // save original for reset
      const reader = new FileReader();
      reader.onload = ev=> state.originalImageDataUrl = ev.target.result;
      reader.readAsDataURL(f);
      state.roi = {x:0,y:0,w:state.imgW,h:state.imgH};
      state.crop = null;
      redraw(true);
      toast('Photo loaded ✔️','ok');
    };
    img.onerror = ()=> toast('Failed to load image','err');
    img.src = URL.createObjectURL(f);
  });

  // Canvas interaction
  const wrap = $('#wrap'); const cvs = $('#cvs'); const ctx = cvs.getContext('2d');
  const sel = {active:false,mode:'idle',startX:0,startY:0,handle:null}; // modes: 'drawROI','drawCROP','move','resize'
  function setupCanvas(){ const dpr = Math.max(1,window.devicePixelRatio||1); const r = wrap.getBoundingClientRect();
    const cssW = Math.max(320, r.width), cssH = Math.round(cssW*0.62);
    cvs.style.width=cssW+'px'; cvs.style.height=cssH+'px'; cvs.width=Math.round(cssW*dpr); cvs.height=Math.round(cssH*dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  function imgFilter(){ // CSS-like filter drawn directly on canvas
    const {brightness, contrast, saturation} = state.grid;
    return `brightness(${brightness}%) contrast(${contrast}%) saturate(${saturation}%)`;
  }
  function applyFilter(ctx){ // quick canvas filter emulation
    // We’ll draw image normally and put a translucent overlay for dim;
    // For brightness/contrast/saturation, use offscreen canvas to keep things fast-ish.
    // Simpler: rely on ctx.filter (widely supported).
    ctx.filter = imgFilter();
  }
  function clearFilter(ctx){ ctx.filter = 'none'; }

  function clientToImage(px,py){
    const rect=cvs.getBoundingClientRect(); const cx=px-rect.left, cy=py-rect.top;
    const scale = fitContainScale(state.imgW,state.imgH,rect.width,rect.height);
    const offX = (rect.width - state.imgW*scale)/2; const offY = (rect.height - state.imgH*scale)/2;
    return { x: clamp((cx-offX)/scale, 0, state.imgW), y: clamp((cy-offY)/scale, 0, state.imgH), scale, offX, offY, cw:rect.width, ch:rect.height };
  }

  function redraw(force=false){
    if(force) setupCanvas();
    ctx.clearRect(0,0,cvs.width,cvs.height);
    if(!state.image){ drawChecker(ctx,cvs); return; }
    const rect=cvs.getBoundingClientRect(); const scale=fitContainScale(state.imgW,state.imgH,rect.width,rect.height);
    const offX=(rect.width - state.imgW*scale)/2, offY=(rect.height - state.imgH*scale)/2;

    // Photo (with adjustments)
    ctx.save(); ctx.translate(offX,offY); ctx.scale(scale,scale);
    applyFilter(ctx);
    ctx.drawImage(state.image, 0,0,state.imgW,state.imgH);
    clearFilter(ctx);

    // Optional dim (so photo is visible underneath grid)
    if(state.grid.dim>0){
      ctx.fillStyle = `rgba(0,0,0,${state.grid.dim})`;
      ctx.fillRect(0,0,state.imgW,state.imgH);
    }

    // Show grid & ROI on top
    if(state.roi){
      drawGrid(ctx,state);
      drawROI(ctx, state.roi);
    }
    // Show crop rectangle if in crop mode
    if(sel.mode==='drawCROP' && state.crop){
      drawCropRect(ctx, state.crop);
    }
    ctx.restore();

    placeHandles(); // ROI handles
  }

  function drawChecker(ctx,c){ ctx.fillStyle='#0e1626'; ctx.fillRect(0,0,c.width,c.height);
    ctx.fillStyle='#8aa0b6'; ctx.font='600 16px Inter, system-ui'; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText('Upload a site photo to start', c.width/2, c.height/2);
  }
  function drawROI(ctx,r){ ctx.save(); ctx.strokeStyle='#22d3ee'; ctx.lineWidth=2; ctx.strokeRect(r.x,r.y,r.w,r.h); ctx.restore(); }
  function drawCropRect(ctx,r){ ctx.save(); ctx.strokeStyle='#fbbf24'; ctx.lineWidth=2; ctx.setLineDash([8,6]); ctx.strokeRect(r.x,r.y,r.w,r.h); ctx.restore(); }
  function drawGrid(ctx,s){
    const {roi,grid}=s; if(!roi) return;
    const cW=roi.w/grid.cols, rH=roi.h/grid.rows;
    if(grid.headerShade){ ctx.fillStyle='rgba(12,18,32,.55)';
      if(grid.marginTop>0) ctx.fillRect(roi.x, roi.y-grid.marginTop, roi.w, grid.marginTop);
      if(grid.marginLeft>0) ctx.fillRect(roi.x-grid.marginLeft, roi.y, grid.marginLeft, roi.h);
    }
    ctx.strokeStyle='rgba(255,255,255,.55)'; ctx.lineWidth=1;
    for(let c=0;c<=grid.cols;c++){ const x=roi.x+c*cW; ctx.beginPath(); ctx.moveTo(x,roi.y); ctx.lineTo(x,roi.y+roi.h); ctx.stroke(); }
    for(let r=0;r<=grid.rows;r++){ const y=roi.y+r*rH; ctx.beginPath(); ctx.moveTo(roi.x,y); ctx.lineTo(roi.x+roi.w,y); ctx.stroke(); }
    const fz=Math.max(10, Math.min(18, Math.min(cW,rH)*0.45)); ctx.font=`600 ${fz}px Inter, system-ui`; ctx.textBaseline='middle'; ctx.textAlign='center';
    const drawLabel=(txt,x,y)=>{ ctx.lineWidth=Math.max(2,fz/6); ctx.strokeStyle=grid.labelShadow; ctx.fillStyle=grid.labelColor; ctx.strokeText(txt,x,y); ctx.fillText(txt,x,y); };
    if(grid.orientation==='letters-rows'){
      for(let c=1;c<=grid.cols;c++) drawLabel(String(c), roi.x+(c-0.5)*cW, roi.y-grid.marginTop/2);
      for(let r=1;r<=grid.rows;r++) drawLabel(letterFor(r), roi.x-grid.marginLeft/2, roi.y+(r-0.5)*rH);
    } else {
      for(let c=1;c<=grid.cols;c++) drawLabel(letterFor(c), roi.x+(c-0.5)*cW, roi.y-grid.marginTop/2);
      for(let r=1;r<=grid.rows;r++) drawLabel(String(r), roi.x-grid.marginLeft/2, roi.y+(r-0.5)*rH);
    }
  }

  function placeHandles(){
    $$('.handle',wrap).forEach(h=>h.remove()); if(!state.image || !state.roi) return;
    const rect=cvs.getBoundingClientRect(); const scale=fitContainScale(state.imgW,state.imgH,rect.width,rect.height);
    const offX=(rect.width - state.imgW*scale)/2, offY=(rect.height - state.imgH*scale)/2; const r=state.roi;
    const pts={nw:[r.x,r.y],ne:[r.x+r.w,r.y],sw:[r.x,r.y+r.h],se:[r.x+r.w,r.y+r.h]};
    for(const [dir,[ix,iy]] of Object.entries(pts)){
      const h=document.createElement('div'); h.className='handle'; h.dataset.dir=dir;
      h.style.left=(offX+ix*scale-7)+'px'; h.style.top=(offY+iy*scale-7)+'px'; wrap.appendChild(h);
      on(h,'pointerdown', (e)=>{ sel.mode='resize'; sel.active=true; sel.handle=dir; wrap.setPointerCapture(e.pointerId); e.preventDefault(); });
    }
  }
  function pointInRect(p,r){ return r && p.x>=r.x && p.x<=r.x+r.w && p.y>=r.y && p.y<=r.y+r.h; }
  function normRect(r,s){ const min=10; const x=clamp(r.x,0,s.imgW), y=clamp(r.y,0,s.imgH);
    const w=clamp(r.w,0,s.imgW-x), h=clamp(r.h,0,s.imgH-y); return {x,y,w:Math.max(w,min),h:Math.max(h,min)}; }
  function resizeRect(r, handle, x,y){
    if(handle.includes('w')){ const nx=clamp(x,0,r.x+r.w); r.w=(r.x+r.w)-nx; r.x=nx; }
    if(handle.includes('e')){ const nx=clamp(x,r.x, state.imgW); r.w=nx-r.x; }
    if(handle.includes('n')){ const ny=clamp(y,0,r.y+r.h); r.h=(r.y+r.h)-ny; r.y=ny; }
    if(handle.includes('s')){ const ny=clamp(y,r.y, state.imgH); r.h=ny-r.y; }
  }

  // Pointer events
  on(wrap,'pointerdown', (e)=>{ if(!state.image) return; wrap.setPointerCapture(e.pointerId);
    const {x,y} = clientToImage(e.clientX,e.clientY);
    const hit = hitHandle(x,y, state.roi);
    if(sel.mode==='drawROI'){ sel.active=true; sel.startX=x; sel.startY=y; state.roi={x,y,w:10,h:10}; }
    else if(sel.mode==='drawCROP'){ sel.active=true; sel.startX=x; sel.startY=y; state.crop={x,y,w:10,h:10}; }
    else if(hit){ sel.active=true; sel.mode='resize'; sel.handle=hit; }
    else if(pointInRect({x,y}, state.roi)){ sel.active=true; sel.mode='move'; sel.startX=x; sel.startY=y; }
  });
  on(wrap,'pointermove', (e)=>{ if(!state.image || !sel.active) return;
    const {x,y} = clientToImage(e.clientX,e.clientY);
    if(sel.mode==='drawROI'){ const rx=Math.min(sel.startX,x), ry=Math.min(sel.startY,y), rw=Math.abs(x-sel.startX), rh=Math.abs(y-sel.startY);
      state.roi = normRect({x:rx,y:ry,w:rw,h:rh}, state); redraw(); }
    else if(sel.mode==='drawCROP'){ const rx=Math.min(sel.startX,x), ry=Math.min(sel.startY,y), rw=Math.abs(x-sel.startX), rh=Math.abs(y-sel.startY);
      state.crop = normRect({x:rx,y:ry,w:rw,h:rh}, state); redraw(); }
    else if(sel.mode==='move'){ const dx=x-sel.startX, dy=y-sel.startY; sel.startX=x; sel.startY=y;
      state.roi.x=clamp(state.roi.x+dx,0,state.imgW-state.roi.w); state.roi.y=clamp(state.roi.y+dy,0,state.imgH-state.roi.h); redraw(); }
    else if(sel.mode==='resize'){ resizeRect(state.roi, sel.handle, x,y); redraw(); }
  }, {passive:true});
  ['pointerup','pointercancel','lostpointercapture'].forEach(ev=>on(wrap,ev, ()=>{ sel.active=false; if(sel.mode==='drawROI'||sel.mode==='drawCROP') sel.mode='idle'; }));

  function hitHandle(ix,iy,r){
    if(!r) return null; const h=10;
    const near=(x,y,tx,ty)=>Math.abs(x-tx)<=h && Math.abs(y-ty)<=h;
    if(near(ix,iy,r.x,r.y)) return 'nw';
    if(near(ix,iy,r.x+r.w,r.y)) return 'ne';
    if(near(ix,iy,r.x,r.y+r.h)) return 'sw';
    if(near(ix,iy,r.x+r.w,r.y+r.h)) return 'se';
    return null;
  }

  // Buttons
  on($('#btn-start-roi'),'click', ()=> { if(!state.image) return toast('Upload a photo first','warn'); sel.mode='drawROI'; toast('Drag to draw grid area'); });
  on($('#btn-reset-roi'),'click', ()=> { if(!state.image) return; state.roi = {x:0,y:0,w:state.imgW,h:state.imgH}; redraw(true); });
  on($('#btn-save-grid'),'click', ()=> { if(!state.image) return toast('Upload a photo first','warn'); if(!state.roi) return toast('Draw a grid area','warn'); toast('Grid saved ✔️','ok'); });

  on($('#btn-start-crop'),'click', ()=> { if(!state.image) return toast('Upload a photo first','warn'); sel.mode='drawCROP'; toast('Drag to pick crop area'); });
  on($('#btn-apply-crop'),'click', ()=> {
    if(!state.image || !state.crop) return toast('No crop area','warn');
    const off = document.createElement('canvas'); off.width=state.crop.w; off.height=state.crop.h;
    const ox = off.getContext('2d'); ox.drawImage(state.image, state.crop.x, state.crop.y, state.crop.w, state.crop.h, 0,0, state.crop.w, state.crop.h);
    const dataURL = off.toDataURL('image/png');
    const img = new Image(); img.onload = ()=>{
      state.image = img; state.imgW=img.naturalWidth; state.imgH=img.naturalHeight;
      state.roi = {x:0,y:0,w:state.imgW,h:state.imgH};
      state.crop = null;
      redraw(true);
      toast('Photo cropped ✔️','ok');
    };
    img.src = dataURL;
  });
  on($('#btn-reset-photo'),'click', ()=>{
    if(!state.originalImageDataUrl) return toast('No original photo saved','warn');
    const img = new Image(); img.onload=()=>{
      state.image = img; state.imgW=img.naturalWidth; state.imgH=img.naturalHeight;
      state.roi = {x:0,y:0,w:state.imgW,h:state.imgH}; state.crop=null; redraw(true); toast('Photo reset ✔️','ok');
    }; img.src = state.originalImageDataUrl;
  });

  redraw(true);
}

/* ===== Entry ===== */
function renderEntry(root){
  root.appendChild(card(`<h2>RCC Results Entry</h2>`,'span-12'));
  const top = card(`
    <div class="row">
      <div class="field"><label>Location</label><input id="t-loc" placeholder="Station / Offset"></div>
      <div class="field"><label>Wet Density (pcf)</label><input id="t-wd" type="number" step="0.1" inputmode="decimal"></div>
      <div class="field"><label>Moisture (%)</label><input id="t-moist" type="number" step="0.1" inputmode="decimal"></div>
      <div class="field"><label>Grid Coord (A3/B12)</label><input id="t-grid" placeholder="A3"></div>
    </div>
    <div class="row">
      <div class="field"><label>Notes</label><textarea id="t-notes" placeholder="Optional comments"></textarea></div>
    </div>
    <div class="row" style="margin-top:8px">
      <button class="btn primary" id="t-add">Add Test</button>
      <button class="btn" id="t-clear">Clear</button>
      <button class="btn ghost" id="t-paste">Paste Text</button>
      <button class="btn" id="t-ocr">Scan Gauge (OCR)</button>
      <button class="btn" id="t-notes-ocr">Notes OCR</button>
    </div>
    <p class="muted small">Grid/markers preview is live below while you enter.</p>
  `,'span-12');
  root.appendChild(top);

  // Live mini preview (grid visible during entry)
  const mini = document.createElement('section'); mini.className='card span-12';
  mini.innerHTML = `<div class="canvasWrap"><canvas id="mini"></canvas></div>`;
  root.appendChild(mini);

  // Wire mini canvas
  const cvs = $('#mini'), ctx = cvs.getContext('2d');
  function setupMini(){ const dpr=Math.max(1,window.devicePixelRatio||1), cssW=Math.min(900, document.body.clientWidth-28), cssH=Math.round(cssW*0.5);
    cvs.style.width=cssW+'px'; cvs.style.height=cssH+'px'; cvs.width=Math.round(cssW*dpr); cvs.height=Math.round(cssH*dpr); ctx.setTransform(dpr,0,0,dpr,0,0); }
  function buildMini(){
    ctx.clearRect(0,0,cvs.width,cvs.height);
    if(!state.image){ ctx.fillStyle='#0e1626'; ctx.fillRect(0,0,cvs.width,cvs.height);
      ctx.fillStyle='#8aa0b6'; ctx.font='600 14px Inter'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText('Upload a photo in Setup', cvs.width/2, cvs.height/2); return; }
    const rect=cvs.getBoundingClientRect(); const scale=fitContainScale(state.imgW,state.imgH,rect.width,rect.height);
    const offX=(rect.width - state.imgW*scale)/2, offY=(rect.height - state.imgH*scale)/2;
    ctx.save(); ctx.translate(offX,offY); ctx.scale(scale,scale);
    ctx.drawImage(state.image, 0,0,state.imgW,state.imgH);
    if(state.roi) drawGridMini(ctx,state);
    drawMarkers(ctx,state);
    ctx.restore();
  }
  function drawGridMini(ctx,s){ // same as setup grid (lighter)
    const {roi,grid}=s; if(!roi) return;
    const cW=roi.w/grid.cols, rH=roi.h/grid.rows;
    ctx.strokeStyle='rgba(255,255,255,.45)'; ctx.lineWidth=1;
    for(let c=0;c<=grid.cols;c++){ const x=roi.x+c*cW; ctx.beginPath(); ctx.moveTo(x,roi.y); ctx.lineTo(x,roi.y+roi.h); ctx.stroke(); }
    for(let r=0;r<=grid.rows;r++){ const y=roi.y+r*rH; ctx.beginPath(); ctx.moveTo(roi.x,y); ctx.lineTo(roi.x+roi.w,y); ctx.stroke(); }
    const fz = 12; ctx.font=`600 ${fz}px Inter`; ctx.textBaseline='middle'; ctx.textAlign='center';
    const draw=(txt,x,y)=>{ ctx.lineWidth=2; ctx.strokeStyle='#000'; ctx.fillStyle='#fff'; ctx.strokeText(txt,x,y); ctx.fillText(txt,x,y); };
    if(state.grid.orientation==='letters-rows'){
      for(let c=1;c<=state.grid.cols;c++) draw(String(c), roi.x+(c-0.5)*cW, roi.y-state.grid.marginTop/2);
      for(let r=1;r<=state.grid.rows;r++) draw(letterFor(r), roi.x-state.grid.marginLeft/2, roi.y+(r-0.5)*rH);
    } else {
      for(let c=1;c<=state.grid.cols;c++) draw(letterFor(c), roi.x+(c-0.5)*cW, roi.y-state.grid.marginTop/2);
      for(let r=1;r<=state.grid.rows;r++) draw(String(r), roi.x-state.grid.marginLeft/2, roi.y+(r-0.5)*rH);
    }
  }
  function drawMarkers(ctx,s){
    ctx.font='700 12px Inter'; ctx.textAlign='center'; ctx.textBaseline='middle';
    s.tests.forEach(t=>{
      if(isNum(t.x)&&isNum(t.y)){
        ctx.beginPath(); ctx.fillStyle='#22d3ee'; ctx.strokeStyle='#0b1220'; ctx.lineWidth=2; ctx.arc(t.x,t.y,8,0,Math.PI*2); ctx.fill(); ctx.stroke();
        ctx.fillStyle='#0b1220'; ctx.fillText(String(t.num), t.x, t.y+0.5);
        ctx.strokeStyle='rgba(255,255,255,.85)'; ctx.lineWidth=3; ctx.strokeText(String(t.num), t.x, t.y+0.5);
        ctx.fillStyle='#fff'; ctx.fillText(String(t.num), t.x, t.y+0.5);
      }
    });
  }
  setupMini(); buildMini();

  // Entry controls
  on($('#t-paste'),'click', async ()=>{
    try{
      const txt = await navigator.clipboard.readText();
      if(!txt) return toast('Clipboard empty','warn');
      const parsed = parsePasted(txt);
      if(parsed.wd!=null) $('#t-wd').value=parsed.wd;
      if(parsed.moist!=null) $('#t-moist').value=parsed.moist;
      if(parsed.coord) $('#t-grid').value=parsed.coord;
      toast('Pasted ✔️','ok');
    }catch{ toast('Clipboard blocked','warn'); }
  });
  on($('#t-ocr'),'click', ()=> $('#ocr-file').click());
  on($('#t-notes-ocr'),'click', ()=> $('#notes-file').click());

  on($('#t-add'),'click', ()=>{
    const location = $('#t-loc').value.trim();
    const wd = toNum($('#t-wd').value);
    const moist = toNum($('#t-moist').value);
    const notes = $('#t-notes').value.trim();
    const coordTxt = $('#t-grid').value.trim().toUpperCase();
    const v = validateCoord(coordTxt, state.grid);
    if (coordTxt && !v.ok) return toast(v.msg,'warn');
    let row=null,col=null,x=null,y=null;
    if(coordTxt){
      const rc = parseCoord(coordTxt, state.grid); if(!rc) return toast('Invalid coord','warn');
      row=rc.row; col=rc.col; const p = gridCellCenterPx(row,col,state.roi,state.grid);
      if(!p) return toast('Coord outside grid','warn'); x=p.x; y=p.y;
    }
    const id = cryptoId(); const num = state.tests.length+1;
    state.tests.push({id,num,location,wd,moist,coord:coordTxt,row,col,x,y,notes});
    state.cursor = state.tests.length-1;
    $('#t-loc').value=''; $('#t-wd').value=''; $('#t-moist').value=''; $('#t-grid').value=''; $('#t-notes').value='';
    buildMini();
    toast(`Test #${num} added ✔️`,'ok');
  });
  on($('#t-clear'),'click', ()=>{ $('#t-loc').value=''; $('#t-wd').value=''; $('#t-moist').value=''; $('#t-grid').value=''; $('#t-notes').value=''; });
}

/* ===== Summary ===== */
function renderSummary(root){
  root.appendChild(card(`
    <div class="row" style="justify-content:space-between">
      <h2>Summary</h2>
      <div class="badge"><span class="dot"></span> ${escapeHtml(state.job.name||'Untitled')} • ${state.job.date}</div>
    </div>`,'span-12'));

  // Annotated photo
  const anno = document.createElement('section'); anno.className='card span-12';
  anno.innerHTML = `
    <div class="row" style="justify-content:space-between;align-items:center;margin-bottom:8px">
      <strong>Annotated Site Photo</strong>
      <div class="row">
        <button class="btn" id="btn-regen">Rebuild</button>
        <button class="btn" id="btn-png">Save PNG</button>
        <button class="btn" id="btn-pdf">Save PDF</button>
        <button class="btn" id="btn-csv">Save CSV</button>
        <button class="btn" id="btn-svg">Save SVG</button>
        <button class="btn" id="btn-share">Share Link</button>
      </div>
    </div>
    <div class="muted small" id="job-meta"></div>
    <div class="canvasWrap"><canvas id="anno"></canvas></div>`;
  root.appendChild(anno);

  // Tests table
  const table = document.createElement('section'); table.className='card span-12';
  table.innerHTML = `
    <h3 style="margin:0 0 8px">Tests</h3>
    <div style="overflow:auto;max-height:420px">
      <table id="sum-table"><thead><tr>
        <th style="width:50px">#</th><th>Location</th>
        <th style="width:120px">Wet Density</th><th style="width:100px">Moisture</th>
        <th style="width:90px">Grid</th><th>Notes</th><th style="width:84px"></th>
      </tr></thead><tbody></tbody></table>
    </div>`;
  root.appendChild(table);

  // Job meta
  $('#job-meta').textContent = [
    state.job.jobAddress ? `Address: ${state.job.jobAddress}` : '',
    isNum(state.job.overallDepth) ? `Overall Depth: ${state.job.overallDepth} in.` : '',
    isNum(state.job.mileage) ? `Round-trip: ${state.job.mileage.toFixed(1)} mi (GCI ↔ Job)` : ''
  ].filter(Boolean).join(' • ');

  // Canvas build
  const cvs=$('#anno'), ctx=cvs.getContext('2d'); setupHiDPI(cvs, 900);
  function setupHiDPI(canvas, cssW=900){ const dpr=Math.max(1,window.devicePixelRatio||1); const cssH=Math.round(cssW*0.62);
    canvas.style.width=cssW+'px'; canvas.style.height=cssH+'px';
    canvas.width=Math.round(cssW*dpr); canvas.height=Math.round(cssH*dpr); ctx.setTransform(dpr,0,0,dpr,0,0); }

  function buildAnnotated(){
    ctx.clearRect(0,0,cvs.width,cvs.height);
    if(!state.image){ ctx.fillStyle='#0e1626'; ctx.fillRect(0,0,cvs.width,cvs.height);
      ctx.fillStyle='#8aa0b6'; ctx.font='600 16px Inter'; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText('Upload a site photo in Setup', cvs.width/2, cvs.height/2); return; }
    const rect=cvs.getBoundingClientRect(); const scale=fitContainScale(state.imgW,state.imgH,rect.width,rect.height);
    const offX=(rect.width - state.imgW*scale)/2, offY=(rect.height - state.imgH*scale)/2;
    ctx.save(); ctx.translate(offX,offY); ctx.scale(scale,scale);
    ctx.drawImage(state.image, 0,0,state.imgW,state.imgH);
    if(state.roi) drawGridSummary(ctx,state);
    drawMarkersSummary(ctx,state);
    ctx.restore();
  }
  function drawGridSummary(ctx,s){ // same style as setup
    const {roi,grid}=s; if(!roi) return;
    const cW=roi.w/grid.cols, rH=roi.h/grid.rows;
    if(grid.headerShade){ ctx.fillStyle='rgba(12,18,32,.55)';
      if(grid.marginTop>0) ctx.fillRect(roi.x, roi.y-grid.marginTop, roi.w, grid.marginTop);
      if(grid.marginLeft>0) ctx.fillRect(roi.x-grid.marginLeft, roi.y, grid.marginLeft, roi.h); }
    ctx.strokeStyle='rgba(255,255,255,.55)'; ctx.lineWidth=1;
    for(let c=0;c<=grid.cols;c++){ const x=roi.x+c*cW; ctx.beginPath(); ctx.moveTo(x,roi.y); ctx.lineTo(x,roi.y+roi.h); ctx.stroke(); }
    for(let r=0;r<=grid.rows;r++){ const y=roi.y+r*rH; ctx.beginPath(); ctx.moveTo(roi.x,y); ctx.lineTo(roi.x+roi.w,y); ctx.stroke(); }
    const fz=Math.max(10, Math.min(18, Math.min(cW,rH)*0.45));
    const draw=(txt,x,y)=>{ ctx.lineWidth=Math.max(2,fz/6); ctx.strokeStyle=state.grid.labelShadow; ctx.fillStyle=state.grid.labelColor; ctx.strokeText(txt,x,y); ctx.fillText(txt,x,y); };
    ctx.font=`600 ${fz}px Inter`; ctx.textBaseline='middle'; ctx.textAlign='center';
    if(state.grid.orientation==='letters-rows'){
      for(let c=1;c<=state.grid.cols;c++) draw(String(c), roi.x+(c-0.5)*cW, roi.y-state.grid.marginTop/2);
      for(let r=1;r<=state.grid.rows;r++) draw(letterFor(r), roi.x-state.grid.marginLeft/2, roi.y+(r-0.5)*rH);
    } else {
      for(let c=1;c<=state.grid.cols;c++) draw(letterFor(c), roi.x+(c-0.5)*cW, roi.y-state.grid.marginTop/2);
      for(let r=1;r<=state.grid.rows;r++) draw(String(r), roi.x-state.grid.marginLeft/2, roi.y+(r-0.5)*rH);
    }
  }
  function drawMarkersSummary(ctx,s){
    ctx.font='700 14px Inter'; ctx.textAlign='center'; ctx.textBaseline='middle';
    s.tests.forEach(t=>{
      if(isNum(t.x)&&isNum(t.y)){
        ctx.beginPath(); ctx.fillStyle='#22d3ee'; ctx.strokeStyle='#0b1220'; ctx.lineWidth=2; ctx.arc(t.x,t.y,10,0,Math.PI*2); ctx.fill(); ctx.stroke();
        ctx.fillStyle='#0b1220'; ctx.fillText(String(t.num), t.x, t.y+0.5);
        ctx.strokeStyle='rgba(255,255,255,.85)'; ctx.lineWidth=3; ctx.strokeText(String(t.num), t.x, t.y+0.5);
        ctx.fillStyle='#fff'; ctx.fillText(String(t.num), t.x, t.y+0.5);
      }
    });
  }

  on($('#btn-regen'),'click', ()=>{ buildAnnotated(); toast('Rebuilt'); });
  on($('#btn-png'),'click', ()=>{ buildAnnotated(); const a=document.createElement('a'); a.download=safeName(state.job.name||'rcc')+'-annotated.png'; a.href=cvs.toDataURL('image/png'); a.click(); });
  on($('#btn-pdf'),'click', ()=> exportPDF(cvs));
  on($('#btn-csv'),'click', ()=> exportCSV());
  on($('#btn-svg'),'click', ()=> exportSVG());
  on($('#btn-share'),'click', ()=> { const url = buildShareURL(); navigator.clipboard.writeText(url).then(()=>toast('Share link copied ✔️','ok')); });

  // Table with inline edits
  const tbody = $('#sum-table tbody');
  function rebuild(){
    tbody.innerHTML='';
    for(const t of state.tests){
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td>${t.num}</td>
        <td><input value="${escapeHtml(t.location||'')}" data-k="location"></td>
        <td><input type="number" step="0.1" value="${isNum(t.wd)?t.wd:''}" data-k="wd"></td>
        <td><input type="number" step="0.1" value="${isNum(t.moist)?t.moist:''}" data-k="moist"></td>
        <td><input value="${escapeHtml(t.coord||'')}" data-k="coord"></td>
        <td><input value="${escapeHtml(t.notes||'')}" data-k="notes"></td>
        <td><button class="btn danger" data-del="${t.id}">Delete</button></td>`;
      tr.querySelectorAll('input').forEach(inp=>{
        on(inp,'keydown',e=>{ if(e.key==='Enter') inp.blur(); });
        on(inp,'blur', ()=>{
          const k = inp.dataset.k; const v = inp.type==='number' ? (inp.value===''?null:parseFloat(inp.value)) : inp.value.trim();
          if(k==='coord'){
            if(v){
              const val = validateCoord(v, state.grid); if(!val.ok){ toast(val.msg,'warn'); inp.focus(); return; }
              const rc = parseCoord(v, state.grid); const p = gridCellCenterPx(rc.row, rc.col, state.roi, state.grid);
              Object.assign(t, {coord:v.toUpperCase(), row:rc.row, col:rc.col, x:p?.x??null, y:p?.y??null});
            } else { Object.assign(t, {coord:'', row:null,col:null,x:null,y:null}); }
          } else { t[k] = v; }
          buildAnnotated();
        });
      });
      on(tr.querySelector('button[data-del]'),'click', ()=>{
        const i = state.tests.findIndex(x=>x.id===t.id); if(i>=0){ state.tests.splice(i,1); renumber(); rebuild(); buildAnnotated(); }
      });
      tbody.appendChild(tr);
    }
  }
  function renumber(){ state.tests.forEach((t,i)=>t.num=i+1); }

  rebuild(); buildAnnotated();
}

/* ---------- Global sticky bar actions ---------- */
function bindGlobalBar(){
  on($('#bar-prev'),'click', ()=> cycle(-1));
  on($('#bar-next'),'click', ()=> cycle(1));
  on($('#bar-update'),'click', ()=> {
    if(state.cursor==null || !state.tests[state.cursor]) return toast('No test selected','warn');
    if(location.hash.replace('#','')!=='/entry') location.hash='#/entry';
    const t = state.tests[state.cursor];
    t.location = $('#t-loc').value.trim();
    t.wd = toNum($('#t-wd').value);
    t.moist = toNum($('#t-moist').value);
    const coordTxt = $('#t-grid').value.trim().toUpperCase();
    if(coordTxt){
      const val=validateCoord(coordTxt,state.grid); if(!val.ok) return toast(val.msg,'warn');
      const rc=parseCoord(coordTxt,state.grid); const p=gridCellCenterPx(rc.row,rc.col,state.roi,state.grid);
      Object.assign(t,{coord:coordTxt,row:rc.row,col:rc.col,x:p?.x??null,y:p?.y??null});
    } else { Object.assign(t,{coord:'',row:null,col:null,x:null,y:null}); }
    t.notes = $('#t-notes').value.trim();
    toast('Updated ✔️','ok');
  });

  // GPS
  on($('#bar-gps'),'click', ()=>{
    if(!navigator.geolocation) return toast('GPS not available','warn');
    navigator.geolocation.getCurrentPosition(
      pos=>{ state.job.gps = {lat:pos.coords.latitude, lon:pos.coords.longitude, acc:pos.coords.accuracy};
             toast(`GPS: ${state.job.gps.lat.toFixed(5)}, ${state.job.gps.lon.toFixed(5)} (±${Math.round(state.job.gps.acc)}m)`,'ok'); },
      err=> toast('GPS denied','warn'),
      { enableHighAccuracy:true, timeout:8000, maximumAge:0 }
    );
  });

  // File inputs for OCR
  on($('#bar-ocr'),'click', ()=> $('#ocr-file').click());
  on($('#ocr-file'),'change', async (e)=>{ const f=e.target.files?.[0]; if(!f) return; await handleGaugeOCR(f); e.target.value=''; });
  on($('#bar-notes-ocr'),'click', ()=> $('#notes-file').click());
  on($('#notes-file'),'change', async (e)=>{ const f=e.target.files?.[0]; if(!f) return; await handleNotesOCR(f); e.target.value=''; });
}

function cycle(dir){
  if(!state.tests.length){ state.cursor=null; return toast('No tests yet','warn'); }
  if(state.cursor==null) state.cursor=0; else state.cursor = (state.cursor + dir + state.tests.length) % state.tests.length;
  const t = state.tests[state.cursor];
  if(location.hash.replace('#','')!=='/entry') location.hash='#/entry';
  $('#t-loc').value = t.location||'';
  $('#t-wd').value = isNum(t.wd)?t.wd:'';
  $('#t-moist').value = isNum(t.moist)?t.moist:'';
  $('#t-grid').value = t.coord||'';
  $('#t-notes').value = t.notes||'';
  toast(`Editing test #${t.num}`);
}

/* ---------- Grid/Coord helpers ---------- */
function letterFor(n){ return String.fromCharCode(64+clamp(n,1,26)); }
function validateCoord(txt, grid){
  const t=(txt||'').trim().toUpperCase(); if(!t) return {ok:true};
  const m=t.match(/^([A-Z])(\d{1,3})$|^(\d{1,3})([A-Z])$/); if(!m) return {ok:false,msg:'Use A1..Z200 (one letter + numbers)'};
  let row=null,col=null;
  if(grid.orientation==='letters-rows'){
    if(m[1]){ row=m[1].charCodeAt(0)-64; col=parseInt(m[2],10); } else { row=m[4].charCodeAt(0)-64; col=parseInt(m[3],10); }
  } else {
    if(m[1]){ row=parseInt(m[2],10); col=m[1].charCodeAt(0)-64; } else { row=parseInt(m[3],10); col=m[4].charCodeAt(0)-64; }
  }
  if(!(row>=1 && row<=grid.rows)) return {ok:false,msg:`Row 1..${grid.rows}`};
  if(!(col>=1 && col<=grid.cols)) return {ok:false,msg:`Col 1..${grid.cols}`};
  return {ok:true};
}
function parseCoord(txt, grid){
  const t=(txt||'').trim().toUpperCase(); const m=t.match(/^([A-Z])(\d{1,3})$|^(\d{1,3})([A-Z])$/); if(!m) return null;
  if(grid.orientation==='letters-rows'){ const row=(m[1]?m[1]:m[4]).charCodeAt(0)-64; const col=parseInt((m[2]?m[2]:m[3]),10); return {row,col}; }
  else { const row=parseInt((m[2]?m[2]:m[3]),10); const col=(m[1]?m[1]:m[4]).charCodeAt(0)-64; return {row,col}; }
}
function gridCellCenterPx(row,col,roi,grid){
  if(!roi) return null; if(!(row>=1 && col>=1)) return null; if(row>grid.rows || col>grid.cols) return null;
  const cw=roi.w/grid.cols, rh=roi.h/grid.rows;
  return { x: roi.x + (col-0.5)*cw, y: roi.y + (row-0.5)*rh };
}

/* ---------- OCR: Gauge & Notes ---------- */
async function handleGaugeOCR(file){
  try{
    toast('Scanning gauge…');
    const text = await ocr(file, '0123456789.%');
    const {wd, moist} = parseGaugeNumbers(text);
    if(wd!=null) $('#t-wd').value = wd;
    if(moist!=null) $('#t-moist').value = moist;
    toast(`OCR ✔️ WD: ${wd??'—'} Moist: ${moist??'—'}`,'ok');
  }catch(e){ console.error(e); toast('OCR failed','err'); }
}
async function handleNotesOCR(file){
  try{
    toast('Reading notes…');
    const text = await ocr(file);
    const current = $('#t-notes').value;
    $('#t-notes').value = current ? (current + '\\n' + text.trim()) : text.trim();
    toast('Notes OCR ✔️','ok');
  }catch(e){ console.error(e); toast('Notes OCR failed','err'); }
}
async function ocr(blob, whitelist){
  if(!window.Tesseract) throw new Error('OCR engine not loaded');
  const worker = await Tesseract.createWorker('eng', 1, { logger:()=>{} });
  try{
    const { data } = await worker.recognize(blob, whitelist ? { tessedit_char_whitelist: whitelist } : undefined);
    return (data?.text||'').trim();
  } finally { await worker.terminate(); }
}
function parseGaugeNumbers(text){
  const raw = text.replace(/[O]/g,'0'); const all = Array.from(raw.matchAll(/(\d{1,3}(?:[.,]\d{1,2})?)\s*%?/g)).map(m=>m[1]);
  const nums = all.map(t=>Number(String(t).replace(',', '.'))).filter(isNum);
  const wet = nums.filter(n=>n>=80 && n<=200).sort((a,b)=>b-a)[0] ?? nums.sort((a,b)=>b-a)[0] ?? null;
  const moist = nums.filter(n=>n>=0 && n<=60).sort((a,b)=>b-a)[0] ?? null;
  const r1 = x=>x==null?null:Math.round(x*10)/10;
  return { wd:r1(wet), moist:r1(moist) };
}
  const mo = /(?:moist\w*|water)\D{0,4}(\d{1,2}(?:\.\d)?)\s*%?/i.exec(txt)?.[1];
  const coord = /\b([A-Z]\d{1,3}|\d{1,3}[A-Z])\b/.exec(txt)?.[1];
  return { wd: wd?Number(wd):null, moist: mo?Number(mo):null, coord: coord?.toUpperCase()||'' };
}

/* ---------- Exporters ---------- */
function exportCSV(){
  const header = ['num','location','wet_density','moisture','grid','notes'];
  const csv = [header.join(',')].concat(
    state.tests.map(t=>[t.num,t.location,t.wd??'',t.moist??'',t.coord??'',t.notes??''].map(v=>JSON.stringify(v)).join(','))
  ).join('\n');
  const blob=new Blob([csv],{type:'text/csv;charset=utf-8;'}); const url=URL.createObjectURL(blob);
  const a=document.createElement('a'); a.href=url; a.download=safeName(state.job.name||'rcc')+'.csv'; a.click(); URL.revokeObjectURL(url);
}

function exportPDF(cvs){
  const { jsPDF } = window.jspdf; const pdf = new jsPDF({orientation:'landscape', unit:'pt', format:'a4'});
  const m=28; const pgW=pdf.internal.pageSize.getWidth();
  const iw = pgW - m*2; const ih = (cvs.height/cvs.width)*iw;
  // header
  pdf.setFont('helvetica','bold'); pdf.setFontSize(14);
  pdf.text((state.job.name||'RCC Report') + ' — ' + state.job.date, m, 26);
  pdf.setFontSize(10);
  const meta = [
    state.job.jobAddress ? `Address: ${state.job.jobAddress}` : null,
    Number.isFinite(state.job.overallDepth) ? `Overall Depth: ${state.job.overallDepth} in.` : null,
    Number.isFinite(state.job.mileage) ? `Round-trip: ${state.job.mileage.toFixed(1)} mi (GCI ↔ Job)` : null,
    state.job.gps ? `GPS: ${state.job.gps.lat.toFixed(5)}, ${state.job.gps.lon.toFixed(5)} (±${Math.round(state.job.gps.acc)}m)` : null
  ].filter(Boolean);
  let y=40; meta.forEach(line=>{ pdf.text(line, m, y); y+=12; });
  // image
  const img = cvs.toDataURL('image/png');
  pdf.addImage(img, 'PNG', m, y, iw, ih, undefined, 'FAST');
  y += ih + 14;
  // table
  const headers=['#','Location','Wet','Moist','Grid','Notes'], col=[22,220,70,60,60,260];
  pdf.setFontSize(10); pdf.setFont('helvetica','bold');
  headers.forEach((h,i)=>pdf.text(h, m+col.slice(0,i).reduce((a,b)=>a+b,0), y));
  y+=12; pdf.setFont('helvetica','normal');
  for(const t of state.tests){
    const row=[t.num, t.location||'', isNum(t.wd)?String(t.wd):'', isNum(t.moist)?String(t.moist):'', t.coord||'', (t.notes||'').slice(0,120)];
    row.forEach((v,i)=> pdf.text(String(v), m+col.slice(0,i).reduce((a,b)=>a+b,0), y));
    y+=12; if(y>pdf.internal.pageSize.getHeight()-40){ pdf.addPage(); y=40; }
  }
  pdf.save(safeName(state.job.name||'rcc')+'-report.pdf');
}

function exportSVG(){
  if(!state.image || !state.roi) return toast('Need a photo + grid','warn');
  const imgW=state.imgW, imgH=state.imgH; const svgNS='http://www.w3.org/2000/svg';
  const svg=document.createElementNS(svgNS,'svg'); svg.setAttribute('xmlns',svgNS); svg.setAttribute('width',imgW); svg.setAttribute('height',imgH);
  // base raster
  const image=document.createElementNS(svgNS,'image');
  image.setAttributeNS(null,'href', state.image.src); image.setAttribute('x','0'); image.setAttribute('y','0'); image.setAttribute('width',imgW); image.setAttribute('height',imgH);
  svg.appendChild(image);
  // grid
  const {roi,grid}=state; const cW=roi.w/grid.cols, rH=roi.h/grid.rows;
  if(grid.headerShade){
    const top=document.createElementNS(svgNS,'rect'); top.setAttribute('x',roi.x); top.setAttribute('y',roi.y-grid.marginTop); top.setAttribute('width',roi.w); top.setAttribute('height',grid.marginTop);
    top.setAttribute('fill','rgba(12,18,32,0.55)'); svg.appendChild(top);
    const left=document.createElementNS(svgNS,'rect'); left.setAttribute('x',roi.x-grid.marginLeft); left.setAttribute('y',roi.y); left.setAttribute('width',grid.marginLeft); left.setAttribute('height',roi.h);
    left.setAttribute('fill','rgba(12,18,32,0.55)'); svg.appendChild(left);
  }
  const gridGroup=document.createElementNS(svgNS,'g'); gridGroup.setAttribute('stroke','rgba(255,255,255,0.55)'); gridGroup.setAttribute('stroke-width','1'); svg.appendChild(gridGroup);
  for(let c=0;c<=grid.cols;c++){ const x=roi.x+c*cW; const l=document.createElementNS(svgNS,'line'); l.setAttribute('x1',x); l.setAttribute('x2',x); l.setAttribute('y1',roi.y); l.setAttribute('y2',roi.y+roi.h); gridGroup.appendChild(l); }
  for(let r=0;r<=grid.rows;r++){ const y=roi.y+r*rH; const l=document.createElementNS(svgNS,'line'); l.setAttribute('x1',roi.x); l.setAttribute('x2',roi.x+roi.w); l.setAttribute('y1',y); l.setAttribute('y2',y); gridGroup.appendChild(l); }
  const labels=document.createElementNS(svgNS,'g'); labels.setAttribute('font-family','Inter, system-ui'); labels.setAttribute('font-weight','600');
  labels.setAttribute('fill', state.grid.labelColor); svg.appendChild(labels);
  const fz=Math.max(10, Math.min(18, Math.min(cW,rH)*0.45));
  if(grid.orientation==='letters-rows'){
    for(let c=1;c<=grid.cols;c++) labels.appendChild(svgText(String(c), roi.x+(c-0.5)*cW, roi.y-grid.marginTop/2, fz));
    for(let r=1;r<=grid.rows;r++) labels.appendChild(svgText(letterFor(r), roi.x-grid.marginLeft/2, roi.y+(r-0.5)*rH, fz));
  } else {
    for(let c=1;c<=grid.cols;c++) labels.appendChild(svgText(letterFor(c), roi.x+(c-0.5)*cW, roi.y-state.grid.marginTop/2, fz));
    for(let r=1;r<=grid.rows;r++) labels.appendChild(svgText(String(r), roi.x-state.grid.marginLeft/2, roi.y+(r-0.5)*rH, fz));
  }
  // markers
  const pins=document.createElementNS(svgNS,'g'); svg.appendChild(pins);
  for(const t of state.tests){
    if(isNum(t.x)&&isNum(t.y)){
      const g=document.createElementNS(svgNS,'g');
      const circle=document.createElementNS(svgNS,'circle'); circle.setAttribute('cx',t.x); circle.setAttribute('cy',t.y); circle.setAttribute('r',10);
      circle.setAttribute('fill','#22d3ee'); circle.setAttribute('stroke','#0b1220'); circle.setAttribute('stroke-width','2'); g.appendChild(circle);
      const n=document.createElementNS(svgNS,'text'); n.setAttribute('x',t.x); n.setAttribute('y',t.y+0.5); n.setAttribute('text-anchor','middle'); n.setAttribute('dominant-baseline','middle');
      n.setAttribute('font-family','Inter'); n.setAttribute('font-weight','700'); n.setAttribute('fill','#ffffff'); n.textContent=String(t.num); g.appendChild(n);
      pins.appendChild(g);
    }
  }
  const ser = new XMLSerializer(); const blob = new Blob([ser.serializeToString(svg)], {type:'image/svg+xml'});
  const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=safeName(state.job.name||'rcc')+'-annotated.svg'; a.click(); URL.revokeObjectURL(url);

  function svgText(txt,x,y,size){ const t=document.createElementNS(svgNS,'text'); t.setAttribute('x',x); t.setAttribute('y',y);
    t.setAttribute('text-anchor','middle'); t.setAttribute('dominant-baseline','middle'); t.setAttribute('font-size',size); t.textContent=txt; return t; }
}

/* ---------- Share link (URL-safe state) & restore ---------- */
function buildShareURL(){
  const payload = JSON.stringify({
    job: state.job, grid: state.grid,
    roi: state.roi, tests: state.tests.map(({id,...t})=>t) // omit ephemeral ids
  });
  const b64 = btoa(unescape(encodeURIComponent(payload)));
  const base = location.origin + location.pathname + '#/summary';
  return `${base}?s=${b64}`;
}
(function restoreFromURL(){
  const q = new URLSearchParams(location.search); const s=q.get('s'); if(!s) return;
  try{
    const obj=JSON.parse(decodeURIComponent(escape(atob(s))));
    Object.assign(state.job,obj.job||{});
    Object.assign(state.grid,obj.grid||{});
    state.roi=obj.roi||null;
    state.tests=(obj.tests||[]).map((t,i)=>({id:cryptoId(), num:i+1, ...t}));
  }catch{}
})();

/* ---------- Mileage (GCI Westerville ↔ Job, round trip) ---------- */
/* Uses free OSM services (rate-limited):
   - Nominatim for geocoding
   - OSRM public router for driving distance */
async function computeRoundTripMiles(originQuery, destQuery){
  // Geocode both ends
  const [orig, dest] = await Promise.all([geocodeNominatim(originQuery), geocodeNominatim(destQuery)]);
  if(!orig || !dest) throw new Error('Geocoding failed');
  const meters = await osrmDistanceMeters([orig.lon,orig.lat], [dest.lon,dest.lat]);
  const round = meters*2; // round trip
  return round / 1609.344;
}
async function geocodeNominatim(q){
  const url = `https://nominatim.openstreetmap.org/search?format=json&limit=1&q=${encodeURIComponent(q)}`;
  const res = await fetch(url, {headers:{'Accept':'application/json','User-Agent':'RCC-Pro-Logger'}}); if(!res.ok) throw new Error('geocode HTTP '+res.status);
  const arr = await res.json(); if(!arr?.length) return null;
  return { lat: parseFloat(arr[0].lat), lon: parseFloat(arr[0].lon) };
}
async function osrmDistanceMeters([lon1,lat1],[lon2,lat2]){
  const url = `https://router.project-osrm.org/route/v1/driving/${lon1},${lat1};${lon2},${lat2}?overview=false`;
  const res = await fetch(url); if(!res.ok) throw new Error('osrm HTTP '+res.status);
  const json = await res.json(); const dist = json?.routes?.[0]?.distance; if(!isNum(dist)) throw new Error('osrm no route');
  return dist;
}
function mileageLabel(){
  if(state.job.mileageStatus==='ok' && isNum(state.job.mileage)) return `Mileage: ${state.job.mileage.toFixed(1)} mi (GCI ↔ Job, round trip)`;
  if(state.job.mileageStatus==='err') return 'Mileage: failed';
  return 'Mileage: idle';
}

/* ---------- UI helpers ---------- */
function card(inner, span='span-12'){ const c=document.createElement('section'); c.className='card '+span; c.innerHTML=inner; return c; }

/* ---------- Done ---------- */
</script>
</body>
</html>
